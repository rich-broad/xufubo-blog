// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 1.1.0.
// **********************************************************************

#ifndef __APPLETCOMMON_H_
#define __APPLETCOMMON_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
using namespace std;


namespace HardwareApplet
{
    const std::string getNewTicket = "getNewTicket";

    const std::string getGoodsClassifyList = "getGoodsClassifyList";

    enum COMMRETCODE
    {
        E_SUCCESS = 0,
        E_TARS_ENCODE_ERROR = 1,
        E_TARS_DECODE_ERROR = 2,
        E_TICKET_INVALID = 3,
        E_TICKET_EXPIRED = 4,
        E_TICKET_WILL_EXPIRED = 5,
        E_BUSINESS_ERROR = 6,
        E_BUSINESS_EXCEPTION = 7,
    };
    inline string etos(const COMMRETCODE & e)
    {
        switch(e)
        {
            case E_SUCCESS: return "E_SUCCESS";
            case E_TARS_ENCODE_ERROR: return "E_TARS_ENCODE_ERROR";
            case E_TARS_DECODE_ERROR: return "E_TARS_DECODE_ERROR";
            case E_TICKET_INVALID: return "E_TICKET_INVALID";
            case E_TICKET_EXPIRED: return "E_TICKET_EXPIRED";
            case E_TICKET_WILL_EXPIRED: return "E_TICKET_WILL_EXPIRED";
            case E_BUSINESS_ERROR: return "E_BUSINESS_ERROR";
            case E_BUSINESS_EXCEPTION: return "E_BUSINESS_EXCEPTION";
            default: return "";
        }
    }
    inline int stoe(const string & s, COMMRETCODE & e)
    {
        if(s == "E_SUCCESS")  { e=E_SUCCESS; return 0;}
        if(s == "E_TARS_ENCODE_ERROR")  { e=E_TARS_ENCODE_ERROR; return 0;}
        if(s == "E_TARS_DECODE_ERROR")  { e=E_TARS_DECODE_ERROR; return 0;}
        if(s == "E_TICKET_INVALID")  { e=E_TICKET_INVALID; return 0;}
        if(s == "E_TICKET_EXPIRED")  { e=E_TICKET_EXPIRED; return 0;}
        if(s == "E_TICKET_WILL_EXPIRED")  { e=E_TICKET_WILL_EXPIRED; return 0;}
        if(s == "E_BUSINESS_ERROR")  { e=E_BUSINESS_ERROR; return 0;}
        if(s == "E_BUSINESS_EXCEPTION")  { e=E_BUSINESS_EXCEPTION; return 0;}

        return -1;
    }

    struct SecurityTicket : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.SecurityTicket";
        }
        static string MD5()
        {
            return "efe1ce6a5d6878a0f39d1685a110f4ba";
        }
        SecurityTicket()
        :sessionKey(""),timets(0),signature("")
        {
        }
        void resetDefautlt()
        {
            sessionKey = "";
            timets = 0;
            signature = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(sessionKey, 0);
            _os.write(timets, 1);
            _os.write(signature, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(sessionKey, 0, true);
            _is.read(timets, 1, true);
            _is.read(signature, 2, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(sessionKey,"sessionKey");
            _ds.display(timets,"timets");
            _ds.display(signature,"signature");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(sessionKey, true);
            _ds.displaySimple(timets, true);
            _ds.displaySimple(signature, false);
            return _os;
        }
    public:
        std::string sessionKey;
        tars::Int64 timets;
        std::string signature;
    };
    inline bool operator==(const SecurityTicket&l, const SecurityTicket&r)
    {
        return l.sessionKey == r.sessionKey && l.timets == r.timets && l.signature == r.signature;
    }
    inline bool operator!=(const SecurityTicket&l, const SecurityTicket&r)
    {
        return !(l == r);
    }

    struct DeviceInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.DeviceInfo";
        }
        static string MD5()
        {
            return "c73c13678f156f762d622e8672930c1d";
        }
        DeviceInfo()
        :imei1(""),imei2(""),macAddr(""),brand(""),mode("")
        {
        }
        void resetDefautlt()
        {
            imei1 = "";
            imei2 = "";
            macAddr = "";
            brand = "";
            mode = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(imei1, 0);
            _os.write(imei2, 1);
            _os.write(macAddr, 2);
            _os.write(brand, 3);
            _os.write(mode, 4);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(imei1, 0, true);
            _is.read(imei2, 1, true);
            _is.read(macAddr, 2, true);
            _is.read(brand, 3, true);
            _is.read(mode, 4, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(imei1,"imei1");
            _ds.display(imei2,"imei2");
            _ds.display(macAddr,"macAddr");
            _ds.display(brand,"brand");
            _ds.display(mode,"mode");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(imei1, true);
            _ds.displaySimple(imei2, true);
            _ds.displaySimple(macAddr, true);
            _ds.displaySimple(brand, true);
            _ds.displaySimple(mode, false);
            return _os;
        }
    public:
        std::string imei1;
        std::string imei2;
        std::string macAddr;
        std::string brand;
        std::string mode;
    };
    inline bool operator==(const DeviceInfo&l, const DeviceInfo&r)
    {
        return l.imei1 == r.imei1 && l.imei2 == r.imei2 && l.macAddr == r.macAddr && l.brand == r.brand && l.mode == r.mode;
    }
    inline bool operator!=(const DeviceInfo&l, const DeviceInfo&r)
    {
        return !(l == r);
    }

    struct ROMInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ROMInfo";
        }
        static string MD5()
        {
            return "521b134839584223864dd6e99c930860";
        }
        ROMInfo()
        :sysId(""),sysVersionName(""),sysVersionCode(""),rootFlag(0)
        {
        }
        void resetDefautlt()
        {
            sysId = "";
            sysVersionName = "";
            sysVersionCode = "";
            rootFlag = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(sysId, 0);
            _os.write(sysVersionName, 1);
            _os.write(sysVersionCode, 2);
            _os.write(rootFlag, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(sysId, 0, true);
            _is.read(sysVersionName, 1, true);
            _is.read(sysVersionCode, 2, true);
            _is.read(rootFlag, 3, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(sysId,"sysId");
            _ds.display(sysVersionName,"sysVersionName");
            _ds.display(sysVersionCode,"sysVersionCode");
            _ds.display(rootFlag,"rootFlag");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(sysId, true);
            _ds.displaySimple(sysVersionName, true);
            _ds.displaySimple(sysVersionCode, true);
            _ds.displaySimple(rootFlag, false);
            return _os;
        }
    public:
        std::string sysId;
        std::string sysVersionName;
        std::string sysVersionCode;
        tars::Int32 rootFlag;
    };
    inline bool operator==(const ROMInfo&l, const ROMInfo&r)
    {
        return l.sysId == r.sysId && l.sysVersionName == r.sysVersionName && l.sysVersionCode == r.sysVersionCode && l.rootFlag == r.rootFlag;
    }
    inline bool operator!=(const ROMInfo&l, const ROMInfo&r)
    {
        return !(l == r);
    }

    struct NetInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.NetInfo";
        }
        static string MD5()
        {
            return "d42e5716eca49c942897abfb5af8d00f";
        }
        NetInfo()
        :netType(0),wifiSsid(""),wifiBssid("")
        {
        }
        void resetDefautlt()
        {
            netType = 0;
            wifiSsid = "";
            wifiBssid = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(netType, 0);
            _os.write(wifiSsid, 1);
            _os.write(wifiBssid, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(netType, 0, true);
            _is.read(wifiSsid, 1, true);
            _is.read(wifiBssid, 2, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(netType,"netType");
            _ds.display(wifiSsid,"wifiSsid");
            _ds.display(wifiBssid,"wifiBssid");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(netType, true);
            _ds.displaySimple(wifiSsid, true);
            _ds.displaySimple(wifiBssid, false);
            return _os;
        }
    public:
        tars::Int32 netType;
        std::string wifiSsid;
        std::string wifiBssid;
    };
    inline bool operator==(const NetInfo&l, const NetInfo&r)
    {
        return l.netType == r.netType && l.wifiSsid == r.wifiSsid && l.wifiBssid == r.wifiBssid;
    }
    inline bool operator!=(const NetInfo&l, const NetInfo&r)
    {
        return !(l == r);
    }

    struct ProxyReqHead : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyReqHead";
        }
        static string MD5()
        {
            return "b3fe637b4e8503eba08cb9e2d7b79958";
        }
        ProxyReqHead()
        :requestId(0),cmd(""),st(""),clientTimestamp(0),svrTimestamp(0)
        {
        }
        void resetDefautlt()
        {
            requestId = 0;
            cmd = "";
            st = "";
            clientTimestamp = 0;
            svrTimestamp = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(requestId, 0);
            _os.write(cmd, 1);
            _os.write(st, 2);
            _os.write(clientTimestamp, 3);
            _os.write(svrTimestamp, 4);
            _os.write(deviceInfo, 5);
            _os.write(romInfo, 6);
            _os.write(netInfo, 7);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(requestId, 0, true);
            _is.read(cmd, 1, true);
            _is.read(st, 2, true);
            _is.read(clientTimestamp, 3, true);
            _is.read(svrTimestamp, 4, true);
            _is.read(deviceInfo, 5, true);
            _is.read(romInfo, 6, true);
            _is.read(netInfo, 7, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(requestId,"requestId");
            _ds.display(cmd,"cmd");
            _ds.display(st,"st");
            _ds.display(clientTimestamp,"clientTimestamp");
            _ds.display(svrTimestamp,"svrTimestamp");
            _ds.display(deviceInfo,"deviceInfo");
            _ds.display(romInfo,"romInfo");
            _ds.display(netInfo,"netInfo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(requestId, true);
            _ds.displaySimple(cmd, true);
            _ds.displaySimple(st, true);
            _ds.displaySimple(clientTimestamp, true);
            _ds.displaySimple(svrTimestamp, true);
            _ds.displaySimple(deviceInfo, true);
            _ds.displaySimple(romInfo, true);
            _ds.displaySimple(netInfo, false);
            return _os;
        }
    public:
        tars::Int32 requestId;
        std::string cmd;
        std::string st;
        tars::Int64 clientTimestamp;
        tars::Int64 svrTimestamp;
        HardwareApplet::DeviceInfo deviceInfo;
        HardwareApplet::ROMInfo romInfo;
        HardwareApplet::NetInfo netInfo;
    };
    inline bool operator==(const ProxyReqHead&l, const ProxyReqHead&r)
    {
        return l.requestId == r.requestId && l.cmd == r.cmd && l.st == r.st && l.clientTimestamp == r.clientTimestamp && l.svrTimestamp == r.svrTimestamp && l.deviceInfo == r.deviceInfo && l.romInfo == r.romInfo && l.netInfo == r.netInfo;
    }
    inline bool operator!=(const ProxyReqHead&l, const ProxyReqHead&r)
    {
        return !(l == r);
    }

    struct ProxyRspHead : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyRspHead";
        }
        static string MD5()
        {
            return "f97109d2b4f77362b237feb6d47eee78";
        }
        ProxyRspHead()
        :ret(HardwareApplet::E_SUCCESS),svrTimestamp(0),csTicketState(0),st(""),requestId(0)
        {
        }
        void resetDefautlt()
        {
            svrTimestamp = 0;
            csTicketState = 0;
            st = "";
            requestId = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write((tars::Int32)ret, 0);
            _os.write(svrTimestamp, 1);
            _os.write(csTicketState, 2);
            _os.write(st, 3);
            _os.write(requestId, 4);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            tars::Int32 eTemp0 = HardwareApplet::E_SUCCESS;
            _is.read(eTemp0, 0, true);
            ret = (HardwareApplet::COMMRETCODE)eTemp0;
            _is.read(svrTimestamp, 1, true);
            _is.read(csTicketState, 2, true);
            _is.read(st, 3, true);
            _is.read(requestId, 4, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display((tars::Int32)ret,"ret");
            _ds.display(svrTimestamp,"svrTimestamp");
            _ds.display(csTicketState,"csTicketState");
            _ds.display(st,"st");
            _ds.display(requestId,"requestId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple((tars::Int32)ret, true);
            _ds.displaySimple(svrTimestamp, true);
            _ds.displaySimple(csTicketState, true);
            _ds.displaySimple(st, true);
            _ds.displaySimple(requestId, false);
            return _os;
        }
    public:
        HardwareApplet::COMMRETCODE ret;
        tars::Int64 svrTimestamp;
        tars::Int32 csTicketState;
        std::string st;
        tars::Int32 requestId;
    };
    inline bool operator==(const ProxyRspHead&l, const ProxyRspHead&r)
    {
        return l.ret == r.ret && l.svrTimestamp == r.svrTimestamp && l.csTicketState == r.csTicketState && l.st == r.st && l.requestId == r.requestId;
    }
    inline bool operator!=(const ProxyRspHead&l, const ProxyRspHead&r)
    {
        return !(l == r);
    }

    struct AppletCommHead : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AppletCommHead";
        }
        static string MD5()
        {
            return "88cd76b96751092805a2590ad53aacb5";
        }
        AppletCommHead()
        :clientTimestamp(0)
        {
        }
        void resetDefautlt()
        {
            clientTimestamp = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(deviceInfo, 0);
            _os.write(romInfo, 1);
            _os.write(netInfo, 2);
            _os.write(st, 3);
            _os.write(clientTimestamp, 4);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(deviceInfo, 0, true);
            _is.read(romInfo, 1, true);
            _is.read(netInfo, 2, true);
            _is.read(st, 3, true);
            _is.read(clientTimestamp, 4, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(deviceInfo,"deviceInfo");
            _ds.display(romInfo,"romInfo");
            _ds.display(netInfo,"netInfo");
            _ds.display(st,"st");
            _ds.display(clientTimestamp,"clientTimestamp");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(deviceInfo, true);
            _ds.displaySimple(romInfo, true);
            _ds.displaySimple(netInfo, true);
            _ds.displaySimple(st, true);
            _ds.displaySimple(clientTimestamp, false);
            return _os;
        }
    public:
        HardwareApplet::DeviceInfo deviceInfo;
        HardwareApplet::ROMInfo romInfo;
        HardwareApplet::NetInfo netInfo;
        HardwareApplet::SecurityTicket st;
        tars::Int64 clientTimestamp;
    };
    inline bool operator==(const AppletCommHead&l, const AppletCommHead&r)
    {
        return l.deviceInfo == r.deviceInfo && l.romInfo == r.romInfo && l.netInfo == r.netInfo && l.st == r.st && l.clientTimestamp == r.clientTimestamp;
    }
    inline bool operator!=(const AppletCommHead&l, const AppletCommHead&r)
    {
        return !(l == r);
    }

    struct WXJSCodeToSessionRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.WXJSCodeToSessionRsp";
        }
        static string MD5()
        {
            return "488e9b29acff7e788053a638a17414f8";
        }
        WXJSCodeToSessionRsp()
        :openid(""),session_key(""),unionid(""),errcode(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            openid = "";
            session_key = "";
            unionid = "";
            errcode = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(openid, 0);
            _os.write(session_key, 1);
            _os.write(unionid, 2);
            _os.write(errcode, 3);
            _os.write(errmsg, 4);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(openid, 0, true);
            _is.read(session_key, 1, true);
            _is.read(unionid, 2, true);
            _is.read(errcode, 3, true);
            _is.read(errmsg, 4, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(openid,"openid");
            _ds.display(session_key,"session_key");
            _ds.display(unionid,"unionid");
            _ds.display(errcode,"errcode");
            _ds.display(errmsg,"errmsg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(openid, true);
            _ds.displaySimple(session_key, true);
            _ds.displaySimple(unionid, true);
            _ds.displaySimple(errcode, true);
            _ds.displaySimple(errmsg, false);
            return _os;
        }
    public:
        std::string openid;
        std::string session_key;
        std::string unionid;
        tars::Int32 errcode;
        std::string errmsg;
    };
    inline bool operator==(const WXJSCodeToSessionRsp&l, const WXJSCodeToSessionRsp&r)
    {
        return l.openid == r.openid && l.session_key == r.session_key && l.unionid == r.unionid && l.errcode == r.errcode && l.errmsg == r.errmsg;
    }
    inline bool operator!=(const WXJSCodeToSessionRsp&l, const WXJSCodeToSessionRsp&r)
    {
        return !(l == r);
    }

    struct GetNewTicketReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetNewTicketReq";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        GetNewTicketReq()
        :wx_code("")
        {
        }
        void resetDefautlt()
        {
            wx_code = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(wx_code, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(wx_code, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(wx_code,"wx_code");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(wx_code, false);
            return _os;
        }
    public:
        std::string wx_code;
    };
    inline bool operator==(const GetNewTicketReq&l, const GetNewTicketReq&r)
    {
        return l.wx_code == r.wx_code;
    }
    inline bool operator!=(const GetNewTicketReq&l, const GetNewTicketReq&r)
    {
        return !(l == r);
    }

    struct GetNewTicketRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetNewTicketRsp";
        }
        static string MD5()
        {
            return "d42e5716eca49c942897abfb5af8d00f";
        }
        GetNewTicketRsp()
        :ret(0),errmsg(""),st("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
            st = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
            _os.write(st, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
            _is.read(st, 2, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            _ds.display(st,"st");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(st, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
        std::string st;
    };
    inline bool operator==(const GetNewTicketRsp&l, const GetNewTicketRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg && l.st == r.st;
    }
    inline bool operator!=(const GetNewTicketRsp&l, const GetNewTicketRsp&r)
    {
        return !(l == r);
    }

    struct ProxyGetNewTicketReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetNewTicketReq";
        }
        static string MD5()
        {
            return "5aec25c8786137819bcf5ec4b4d2c222";
        }
        ProxyGetNewTicketReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::GetNewTicketReq body;
    };
    inline bool operator==(const ProxyGetNewTicketReq&l, const ProxyGetNewTicketReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetNewTicketReq&l, const ProxyGetNewTicketReq&r)
    {
        return !(l == r);
    }

    struct ProxyGetNewTicketRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetNewTicketRsp";
        }
        static string MD5()
        {
            return "928d4e1b43cbba9bb288e2656f572750";
        }
        ProxyGetNewTicketRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::GetNewTicketRsp body;
    };
    inline bool operator==(const ProxyGetNewTicketRsp&l, const ProxyGetNewTicketRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetNewTicketRsp&l, const ProxyGetNewTicketRsp&r)
    {
        return !(l == r);
    }

    struct GetGoodsClassifyListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetGoodsClassifyListReq";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        GetGoodsClassifyListReq()
        :reserved_fields("")
        {
        }
        void resetDefautlt()
        {
            reserved_fields = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (reserved_fields != "")
            {
                _os.write(reserved_fields, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(reserved_fields, 0, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(reserved_fields,"reserved_fields");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(reserved_fields, false);
            return _os;
        }
    public:
        std::string reserved_fields;
    };
    inline bool operator==(const GetGoodsClassifyListReq&l, const GetGoodsClassifyListReq&r)
    {
        return l.reserved_fields == r.reserved_fields;
    }
    inline bool operator!=(const GetGoodsClassifyListReq&l, const GetGoodsClassifyListReq&r)
    {
        return !(l == r);
    }

    struct GoodsClassifyItem : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GoodsClassifyItem";
        }
        static string MD5()
        {
            return "b84e4dd5dd1d7c43dbe702512024405f";
        }
        GoodsClassifyItem()
        :classifyId(0),classifyName("")
        {
        }
        void resetDefautlt()
        {
            classifyId = 0;
            classifyName = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(classifyId, 0);
            _os.write(classifyName, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(classifyId, 0, true);
            _is.read(classifyName, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(classifyId,"classifyId");
            _ds.display(classifyName,"classifyName");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(classifyId, true);
            _ds.displaySimple(classifyName, false);
            return _os;
        }
    public:
        tars::Int32 classifyId;
        std::string classifyName;
    };
    inline bool operator==(const GoodsClassifyItem&l, const GoodsClassifyItem&r)
    {
        return l.classifyId == r.classifyId && l.classifyName == r.classifyName;
    }
    inline bool operator!=(const GoodsClassifyItem&l, const GoodsClassifyItem&r)
    {
        return !(l == r);
    }

    struct GetGoodsClassifyListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetGoodsClassifyListRsp";
        }
        static string MD5()
        {
            return "703c0e0a1abc6793d8220e2d6369c55b";
        }
        GetGoodsClassifyListRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
            if (item_list.size() > 0)
            {
                _os.write(item_list, 2);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
            _is.read(item_list, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            _ds.display(item_list,"item_list");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(item_list, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
        vector<HardwareApplet::GoodsClassifyItem> item_list;
    };
    inline bool operator==(const GetGoodsClassifyListRsp&l, const GetGoodsClassifyListRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg && l.item_list == r.item_list;
    }
    inline bool operator!=(const GetGoodsClassifyListRsp&l, const GetGoodsClassifyListRsp&r)
    {
        return !(l == r);
    }


}



#endif
