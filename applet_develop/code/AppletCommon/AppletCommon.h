// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 1.4.0.
// **********************************************************************

#ifndef __APPLETCOMMON_H_
#define __APPLETCOMMON_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
#include "tup/TarsJson.h"
using namespace std;


namespace HardwareApplet
{
    const std::string cmd0 = "getNewTicket";

    const std::string cmd1 = "getCategoryList";

    const std::string cmd2 = "addCategoryInfo";

    const std::string cmd3 = "getAttributeList";

    const std::string cmd4 = "addAttributeInfo";

    const std::string cmd5 = "getAttributeValueList";

    const std::string cmd6 = "addAttributeValueInfo";

    const std::string cmd7 = "getBrandList";

    const std::string cmd8 = "addBrandInfo";

    const std::string cmd9 = "getMakerList";

    const std::string cmd10 = "addMakerInfo";

    const std::string cmd11 = "getGoodsSPUList";

    const std::string cmd12 = "addGoodsSPUInfo";

    const std::string cmd13 = "addGoodsSKUInfo";

    const std::string cmd14 = "getGoodsSKUList";

    const std::string cmd15 = "addMyAddressInfo";

    const std::string cmd16 = "getMyAddressList";

    const std::string cmd17 = "addGoodsToShopCart";

    const std::string cmd18 = "getMyShopCartInfo";

    const std::string cmd19 = "submitOrder";

    const std::string cmd20 = "confirmOrder";

    const std::string cmd21 = "getProvinceList";

    const std::string cmd22 = "getCityListByProvince";

    const std::string cmd23 = "getCountyListByCity";

    const std::string cmd24 = "getMyOrderList";

    const std::string cmd25 = "getOrderList";

    const std::string cmd26 = "getOrderDetail";

    const std::string cmd27 = "getNewTicket";

    const std::string cmd28 = "confirmGoodsTranPrice";

    const std::string cmd29 = "deliverGoods";

    const std::string cmd30 = "getWarehouseList";

    const std::string cmd31 = "addWarehouseInfo";

    const std::string cmd32 = "transferGoodsStock";

    enum COMMRETCODE
    {
        E_SUCCESS = 0,
        E_TARS_ENCODE_ERROR = 1,
        E_TARS_DECODE_ERROR = 2,
        E_TICKET_INVALID = 3,
        E_TICKET_EXPIRED = 4,
        E_TICKET_WILL_EXPIRED = 5,
        E_BUSINESS_ERROR = 6,
        E_BUSINESS_EXCEPTION = 7,
        E_GET_BUYER_SESSION_ERROR = 8,
        E_CHECK_SELLER_LOGIN_ERROR = 9,
    };
    inline string etos(const COMMRETCODE & e)
    {
        switch(e)
        {
            case E_SUCCESS: return "E_SUCCESS";
            case E_TARS_ENCODE_ERROR: return "E_TARS_ENCODE_ERROR";
            case E_TARS_DECODE_ERROR: return "E_TARS_DECODE_ERROR";
            case E_TICKET_INVALID: return "E_TICKET_INVALID";
            case E_TICKET_EXPIRED: return "E_TICKET_EXPIRED";
            case E_TICKET_WILL_EXPIRED: return "E_TICKET_WILL_EXPIRED";
            case E_BUSINESS_ERROR: return "E_BUSINESS_ERROR";
            case E_BUSINESS_EXCEPTION: return "E_BUSINESS_EXCEPTION";
            case E_GET_BUYER_SESSION_ERROR: return "E_GET_BUYER_SESSION_ERROR";
            case E_CHECK_SELLER_LOGIN_ERROR: return "E_CHECK_SELLER_LOGIN_ERROR";
            default: return "";
        }
    }
    inline int stoe(const string & s, COMMRETCODE & e)
    {
        if(s == "E_SUCCESS")  { e=E_SUCCESS; return 0;}
        if(s == "E_TARS_ENCODE_ERROR")  { e=E_TARS_ENCODE_ERROR; return 0;}
        if(s == "E_TARS_DECODE_ERROR")  { e=E_TARS_DECODE_ERROR; return 0;}
        if(s == "E_TICKET_INVALID")  { e=E_TICKET_INVALID; return 0;}
        if(s == "E_TICKET_EXPIRED")  { e=E_TICKET_EXPIRED; return 0;}
        if(s == "E_TICKET_WILL_EXPIRED")  { e=E_TICKET_WILL_EXPIRED; return 0;}
        if(s == "E_BUSINESS_ERROR")  { e=E_BUSINESS_ERROR; return 0;}
        if(s == "E_BUSINESS_EXCEPTION")  { e=E_BUSINESS_EXCEPTION; return 0;}
        if(s == "E_GET_BUYER_SESSION_ERROR")  { e=E_GET_BUYER_SESSION_ERROR; return 0;}
        if(s == "E_CHECK_SELLER_LOGIN_ERROR")  { e=E_CHECK_SELLER_LOGIN_ERROR; return 0;}

        return -1;
    }

    struct SecurityTicket : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.SecurityTicket";
        }
        static string MD5()
        {
            return "efe1ce6a5d6878a0f39d1685a110f4ba";
        }
        SecurityTicket()
        :sessionKey(""),timets(0),signature("")
        {
        }
        void resetDefautlt()
        {
            sessionKey = "";
            timets = 0;
            signature = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(sessionKey, 0);
            _os.write(timets, 1);
            _os.write(signature, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(sessionKey, 0, true);
            _is.read(timets, 1, true);
            _is.read(signature, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["sessionKey"] = tars::JsonOutput::writeJson(sessionKey);
            p->value["timets"] = tars::JsonOutput::writeJson(timets);
            p->value["signature"] = tars::JsonOutput::writeJson(signature);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(sessionKey,pObj->value["sessionKey"], true);
            tars::JsonInput::readJson(timets,pObj->value["timets"], true);
            tars::JsonInput::readJson(signature,pObj->value["signature"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(sessionKey,"sessionKey");
            _ds.display(timets,"timets");
            _ds.display(signature,"signature");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(sessionKey, true);
            _ds.displaySimple(timets, true);
            _ds.displaySimple(signature, false);
            return _os;
        }
    public:
        std::string sessionKey;
        tars::Int64 timets;
        std::string signature;
    };
    inline bool operator==(const SecurityTicket&l, const SecurityTicket&r)
    {
        return l.sessionKey == r.sessionKey && l.timets == r.timets && l.signature == r.signature;
    }
    inline bool operator!=(const SecurityTicket&l, const SecurityTicket&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const SecurityTicket&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,SecurityTicket&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct DeviceInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.DeviceInfo";
        }
        static string MD5()
        {
            return "c73c13678f156f762d622e8672930c1d";
        }
        DeviceInfo()
        :imei1(""),imei2(""),macAddr(""),brand(""),mode("")
        {
        }
        void resetDefautlt()
        {
            imei1 = "";
            imei2 = "";
            macAddr = "";
            brand = "";
            mode = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(imei1, 0);
            _os.write(imei2, 1);
            _os.write(macAddr, 2);
            _os.write(brand, 3);
            _os.write(mode, 4);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(imei1, 0, true);
            _is.read(imei2, 1, true);
            _is.read(macAddr, 2, true);
            _is.read(brand, 3, true);
            _is.read(mode, 4, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["imei1"] = tars::JsonOutput::writeJson(imei1);
            p->value["imei2"] = tars::JsonOutput::writeJson(imei2);
            p->value["macAddr"] = tars::JsonOutput::writeJson(macAddr);
            p->value["brand"] = tars::JsonOutput::writeJson(brand);
            p->value["mode"] = tars::JsonOutput::writeJson(mode);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(imei1,pObj->value["imei1"], true);
            tars::JsonInput::readJson(imei2,pObj->value["imei2"], true);
            tars::JsonInput::readJson(macAddr,pObj->value["macAddr"], true);
            tars::JsonInput::readJson(brand,pObj->value["brand"], true);
            tars::JsonInput::readJson(mode,pObj->value["mode"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(imei1,"imei1");
            _ds.display(imei2,"imei2");
            _ds.display(macAddr,"macAddr");
            _ds.display(brand,"brand");
            _ds.display(mode,"mode");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(imei1, true);
            _ds.displaySimple(imei2, true);
            _ds.displaySimple(macAddr, true);
            _ds.displaySimple(brand, true);
            _ds.displaySimple(mode, false);
            return _os;
        }
    public:
        std::string imei1;
        std::string imei2;
        std::string macAddr;
        std::string brand;
        std::string mode;
    };
    inline bool operator==(const DeviceInfo&l, const DeviceInfo&r)
    {
        return l.imei1 == r.imei1 && l.imei2 == r.imei2 && l.macAddr == r.macAddr && l.brand == r.brand && l.mode == r.mode;
    }
    inline bool operator!=(const DeviceInfo&l, const DeviceInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const DeviceInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,DeviceInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ROMInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ROMInfo";
        }
        static string MD5()
        {
            return "521b134839584223864dd6e99c930860";
        }
        ROMInfo()
        :sysId(""),sysVersionName(""),sysVersionCode(""),rootFlag(0)
        {
        }
        void resetDefautlt()
        {
            sysId = "";
            sysVersionName = "";
            sysVersionCode = "";
            rootFlag = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(sysId, 0);
            _os.write(sysVersionName, 1);
            _os.write(sysVersionCode, 2);
            _os.write(rootFlag, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(sysId, 0, true);
            _is.read(sysVersionName, 1, true);
            _is.read(sysVersionCode, 2, true);
            _is.read(rootFlag, 3, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["sysId"] = tars::JsonOutput::writeJson(sysId);
            p->value["sysVersionName"] = tars::JsonOutput::writeJson(sysVersionName);
            p->value["sysVersionCode"] = tars::JsonOutput::writeJson(sysVersionCode);
            p->value["rootFlag"] = tars::JsonOutput::writeJson(rootFlag);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(sysId,pObj->value["sysId"], true);
            tars::JsonInput::readJson(sysVersionName,pObj->value["sysVersionName"], true);
            tars::JsonInput::readJson(sysVersionCode,pObj->value["sysVersionCode"], true);
            tars::JsonInput::readJson(rootFlag,pObj->value["rootFlag"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(sysId,"sysId");
            _ds.display(sysVersionName,"sysVersionName");
            _ds.display(sysVersionCode,"sysVersionCode");
            _ds.display(rootFlag,"rootFlag");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(sysId, true);
            _ds.displaySimple(sysVersionName, true);
            _ds.displaySimple(sysVersionCode, true);
            _ds.displaySimple(rootFlag, false);
            return _os;
        }
    public:
        std::string sysId;
        std::string sysVersionName;
        std::string sysVersionCode;
        tars::Int32 rootFlag;
    };
    inline bool operator==(const ROMInfo&l, const ROMInfo&r)
    {
        return l.sysId == r.sysId && l.sysVersionName == r.sysVersionName && l.sysVersionCode == r.sysVersionCode && l.rootFlag == r.rootFlag;
    }
    inline bool operator!=(const ROMInfo&l, const ROMInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ROMInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ROMInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct NetInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.NetInfo";
        }
        static string MD5()
        {
            return "d42e5716eca49c942897abfb5af8d00f";
        }
        NetInfo()
        :netType(0),wifiSsid(""),wifiBssid("")
        {
        }
        void resetDefautlt()
        {
            netType = 0;
            wifiSsid = "";
            wifiBssid = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(netType, 0);
            _os.write(wifiSsid, 1);
            _os.write(wifiBssid, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(netType, 0, true);
            _is.read(wifiSsid, 1, true);
            _is.read(wifiBssid, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["netType"] = tars::JsonOutput::writeJson(netType);
            p->value["wifiSsid"] = tars::JsonOutput::writeJson(wifiSsid);
            p->value["wifiBssid"] = tars::JsonOutput::writeJson(wifiBssid);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(netType,pObj->value["netType"], true);
            tars::JsonInput::readJson(wifiSsid,pObj->value["wifiSsid"], true);
            tars::JsonInput::readJson(wifiBssid,pObj->value["wifiBssid"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(netType,"netType");
            _ds.display(wifiSsid,"wifiSsid");
            _ds.display(wifiBssid,"wifiBssid");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(netType, true);
            _ds.displaySimple(wifiSsid, true);
            _ds.displaySimple(wifiBssid, false);
            return _os;
        }
    public:
        tars::Int32 netType;
        std::string wifiSsid;
        std::string wifiBssid;
    };
    inline bool operator==(const NetInfo&l, const NetInfo&r)
    {
        return l.netType == r.netType && l.wifiSsid == r.wifiSsid && l.wifiBssid == r.wifiBssid;
    }
    inline bool operator!=(const NetInfo&l, const NetInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const NetInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,NetInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct SessionInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.SessionInfo";
        }
        static string MD5()
        {
            return "d42e5716eca49c942897abfb5af8d00f";
        }
        SessionInfo()
        :uid(0),openid(""),unionid("")
        {
        }
        void resetDefautlt()
        {
            uid = 0;
            openid = "";
            unionid = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(uid, 0);
            _os.write(openid, 1);
            _os.write(unionid, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(uid, 0, true);
            _is.read(openid, 1, true);
            _is.read(unionid, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["uid"] = tars::JsonOutput::writeJson(uid);
            p->value["openid"] = tars::JsonOutput::writeJson(openid);
            p->value["unionid"] = tars::JsonOutput::writeJson(unionid);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(uid,pObj->value["uid"], true);
            tars::JsonInput::readJson(openid,pObj->value["openid"], true);
            tars::JsonInput::readJson(unionid,pObj->value["unionid"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(uid,"uid");
            _ds.display(openid,"openid");
            _ds.display(unionid,"unionid");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(uid, true);
            _ds.displaySimple(openid, true);
            _ds.displaySimple(unionid, false);
            return _os;
        }
    public:
        tars::Int32 uid;
        std::string openid;
        std::string unionid;
    };
    inline bool operator==(const SessionInfo&l, const SessionInfo&r)
    {
        return l.uid == r.uid && l.openid == r.openid && l.unionid == r.unionid;
    }
    inline bool operator!=(const SessionInfo&l, const SessionInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const SessionInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,SessionInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyReqHead : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyReqHead";
        }
        static string MD5()
        {
            return "b3fe637b4e8503eba08cb9e2d7b79958";
        }
        ProxyReqHead()
        :requestId(0),cmd(""),st(""),clientTimestamp(0),svrTimestamp(0)
        {
        }
        void resetDefautlt()
        {
            requestId = 0;
            cmd = "";
            st = "";
            clientTimestamp = 0;
            svrTimestamp = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(requestId, 0);
            _os.write(cmd, 1);
            _os.write(st, 2);
            _os.write(clientTimestamp, 3);
            _os.write(svrTimestamp, 4);
            _os.write(deviceInfo, 5);
            _os.write(romInfo, 6);
            _os.write(netInfo, 7);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(requestId, 0, true);
            _is.read(cmd, 1, true);
            _is.read(st, 2, true);
            _is.read(clientTimestamp, 3, true);
            _is.read(svrTimestamp, 4, true);
            _is.read(deviceInfo, 5, true);
            _is.read(romInfo, 6, true);
            _is.read(netInfo, 7, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
            p->value["cmd"] = tars::JsonOutput::writeJson(cmd);
            p->value["st"] = tars::JsonOutput::writeJson(st);
            p->value["clientTimestamp"] = tars::JsonOutput::writeJson(clientTimestamp);
            p->value["svrTimestamp"] = tars::JsonOutput::writeJson(svrTimestamp);
            p->value["deviceInfo"] = tars::JsonOutput::writeJson(deviceInfo);
            p->value["romInfo"] = tars::JsonOutput::writeJson(romInfo);
            p->value["netInfo"] = tars::JsonOutput::writeJson(netInfo);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(requestId,pObj->value["requestId"], true);
            tars::JsonInput::readJson(cmd,pObj->value["cmd"], true);
            tars::JsonInput::readJson(st,pObj->value["st"], true);
            tars::JsonInput::readJson(clientTimestamp,pObj->value["clientTimestamp"], true);
            tars::JsonInput::readJson(svrTimestamp,pObj->value["svrTimestamp"], true);
            tars::JsonInput::readJson(deviceInfo,pObj->value["deviceInfo"], true);
            tars::JsonInput::readJson(romInfo,pObj->value["romInfo"], true);
            tars::JsonInput::readJson(netInfo,pObj->value["netInfo"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(requestId,"requestId");
            _ds.display(cmd,"cmd");
            _ds.display(st,"st");
            _ds.display(clientTimestamp,"clientTimestamp");
            _ds.display(svrTimestamp,"svrTimestamp");
            _ds.display(deviceInfo,"deviceInfo");
            _ds.display(romInfo,"romInfo");
            _ds.display(netInfo,"netInfo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(requestId, true);
            _ds.displaySimple(cmd, true);
            _ds.displaySimple(st, true);
            _ds.displaySimple(clientTimestamp, true);
            _ds.displaySimple(svrTimestamp, true);
            _ds.displaySimple(deviceInfo, true);
            _ds.displaySimple(romInfo, true);
            _ds.displaySimple(netInfo, false);
            return _os;
        }
    public:
        tars::Int32 requestId;
        std::string cmd;
        std::string st;
        tars::Int64 clientTimestamp;
        tars::Int64 svrTimestamp;
        HardwareApplet::DeviceInfo deviceInfo;
        HardwareApplet::ROMInfo romInfo;
        HardwareApplet::NetInfo netInfo;
    };
    inline bool operator==(const ProxyReqHead&l, const ProxyReqHead&r)
    {
        return l.requestId == r.requestId && l.cmd == r.cmd && l.st == r.st && l.clientTimestamp == r.clientTimestamp && l.svrTimestamp == r.svrTimestamp && l.deviceInfo == r.deviceInfo && l.romInfo == r.romInfo && l.netInfo == r.netInfo;
    }
    inline bool operator!=(const ProxyReqHead&l, const ProxyReqHead&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyReqHead&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyReqHead&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyRspHead : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyRspHead";
        }
        static string MD5()
        {
            return "f97109d2b4f77362b237feb6d47eee78";
        }
        ProxyRspHead()
        :ret(HardwareApplet::E_SUCCESS),svrTimestamp(0),csTicketState(0),st(""),requestId(0)
        {
        }
        void resetDefautlt()
        {
            svrTimestamp = 0;
            csTicketState = 0;
            st = "";
            requestId = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write((tars::Int32)ret, 0);
            _os.write(svrTimestamp, 1);
            _os.write(csTicketState, 2);
            _os.write(st, 3);
            _os.write(requestId, 4);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            tars::Int32 eTemp0 = HardwareApplet::E_SUCCESS;
            _is.read(eTemp0, 0, true);
            ret = (HardwareApplet::COMMRETCODE)eTemp0;
            _is.read(svrTimestamp, 1, true);
            _is.read(csTicketState, 2, true);
            _is.read(st, 3, true);
            _is.read(requestId, 4, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson((tars::Int32)ret);
            p->value["svrTimestamp"] = tars::JsonOutput::writeJson(svrTimestamp);
            p->value["csTicketState"] = tars::JsonOutput::writeJson(csTicketState);
            p->value["st"] = tars::JsonOutput::writeJson(st);
            p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(svrTimestamp,pObj->value["svrTimestamp"], true);
            tars::JsonInput::readJson(csTicketState,pObj->value["csTicketState"], true);
            tars::JsonInput::readJson(st,pObj->value["st"], true);
            tars::JsonInput::readJson(requestId,pObj->value["requestId"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display((tars::Int32)ret,"ret");
            _ds.display(svrTimestamp,"svrTimestamp");
            _ds.display(csTicketState,"csTicketState");
            _ds.display(st,"st");
            _ds.display(requestId,"requestId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple((tars::Int32)ret, true);
            _ds.displaySimple(svrTimestamp, true);
            _ds.displaySimple(csTicketState, true);
            _ds.displaySimple(st, true);
            _ds.displaySimple(requestId, false);
            return _os;
        }
    public:
        HardwareApplet::COMMRETCODE ret;
        tars::Int64 svrTimestamp;
        tars::Int32 csTicketState;
        std::string st;
        tars::Int32 requestId;
    };
    inline bool operator==(const ProxyRspHead&l, const ProxyRspHead&r)
    {
        return l.ret == r.ret && l.svrTimestamp == r.svrTimestamp && l.csTicketState == r.csTicketState && l.st == r.st && l.requestId == r.requestId;
    }
    inline bool operator!=(const ProxyRspHead&l, const ProxyRspHead&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyRspHead&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyRspHead&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AppletCommHead : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AppletCommHead";
        }
        static string MD5()
        {
            return "d38ce2600be6a00906ea94874d9b0031";
        }
        AppletCommHead()
        :clientTimestamp(0)
        {
        }
        void resetDefautlt()
        {
            clientTimestamp = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(deviceInfo, 0);
            _os.write(romInfo, 1);
            _os.write(netInfo, 2);
            _os.write(st, 3);
            _os.write(clientTimestamp, 4);
            _os.write(sessionInfo, 5);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(deviceInfo, 0, true);
            _is.read(romInfo, 1, true);
            _is.read(netInfo, 2, true);
            _is.read(st, 3, true);
            _is.read(clientTimestamp, 4, true);
            _is.read(sessionInfo, 5, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["deviceInfo"] = tars::JsonOutput::writeJson(deviceInfo);
            p->value["romInfo"] = tars::JsonOutput::writeJson(romInfo);
            p->value["netInfo"] = tars::JsonOutput::writeJson(netInfo);
            p->value["st"] = tars::JsonOutput::writeJson(st);
            p->value["clientTimestamp"] = tars::JsonOutput::writeJson(clientTimestamp);
            p->value["sessionInfo"] = tars::JsonOutput::writeJson(sessionInfo);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(deviceInfo,pObj->value["deviceInfo"], true);
            tars::JsonInput::readJson(romInfo,pObj->value["romInfo"], true);
            tars::JsonInput::readJson(netInfo,pObj->value["netInfo"], true);
            tars::JsonInput::readJson(st,pObj->value["st"], true);
            tars::JsonInput::readJson(clientTimestamp,pObj->value["clientTimestamp"], true);
            tars::JsonInput::readJson(sessionInfo,pObj->value["sessionInfo"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(deviceInfo,"deviceInfo");
            _ds.display(romInfo,"romInfo");
            _ds.display(netInfo,"netInfo");
            _ds.display(st,"st");
            _ds.display(clientTimestamp,"clientTimestamp");
            _ds.display(sessionInfo,"sessionInfo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(deviceInfo, true);
            _ds.displaySimple(romInfo, true);
            _ds.displaySimple(netInfo, true);
            _ds.displaySimple(st, true);
            _ds.displaySimple(clientTimestamp, true);
            _ds.displaySimple(sessionInfo, false);
            return _os;
        }
    public:
        HardwareApplet::DeviceInfo deviceInfo;
        HardwareApplet::ROMInfo romInfo;
        HardwareApplet::NetInfo netInfo;
        HardwareApplet::SecurityTicket st;
        tars::Int64 clientTimestamp;
        HardwareApplet::SessionInfo sessionInfo;
    };
    inline bool operator==(const AppletCommHead&l, const AppletCommHead&r)
    {
        return l.deviceInfo == r.deviceInfo && l.romInfo == r.romInfo && l.netInfo == r.netInfo && l.st == r.st && l.clientTimestamp == r.clientTimestamp && l.sessionInfo == r.sessionInfo;
    }
    inline bool operator!=(const AppletCommHead&l, const AppletCommHead&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AppletCommHead&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AppletCommHead&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct WXJSCodeToSessionRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.WXJSCodeToSessionRsp";
        }
        static string MD5()
        {
            return "488e9b29acff7e788053a638a17414f8";
        }
        WXJSCodeToSessionRsp()
        :openid(""),session_key(""),unionid(""),errcode(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            openid = "";
            session_key = "";
            unionid = "";
            errcode = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(openid, 0);
            _os.write(session_key, 1);
            _os.write(unionid, 2);
            _os.write(errcode, 3);
            _os.write(errmsg, 4);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(openid, 0, true);
            _is.read(session_key, 1, true);
            _is.read(unionid, 2, true);
            _is.read(errcode, 3, true);
            _is.read(errmsg, 4, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["openid"] = tars::JsonOutput::writeJson(openid);
            p->value["session_key"] = tars::JsonOutput::writeJson(session_key);
            p->value["unionid"] = tars::JsonOutput::writeJson(unionid);
            p->value["errcode"] = tars::JsonOutput::writeJson(errcode);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(openid,pObj->value["openid"], true);
            tars::JsonInput::readJson(session_key,pObj->value["session_key"], true);
            tars::JsonInput::readJson(unionid,pObj->value["unionid"], true);
            tars::JsonInput::readJson(errcode,pObj->value["errcode"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(openid,"openid");
            _ds.display(session_key,"session_key");
            _ds.display(unionid,"unionid");
            _ds.display(errcode,"errcode");
            _ds.display(errmsg,"errmsg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(openid, true);
            _ds.displaySimple(session_key, true);
            _ds.displaySimple(unionid, true);
            _ds.displaySimple(errcode, true);
            _ds.displaySimple(errmsg, false);
            return _os;
        }
    public:
        std::string openid;
        std::string session_key;
        std::string unionid;
        tars::Int32 errcode;
        std::string errmsg;
    };
    inline bool operator==(const WXJSCodeToSessionRsp&l, const WXJSCodeToSessionRsp&r)
    {
        return l.openid == r.openid && l.session_key == r.session_key && l.unionid == r.unionid && l.errcode == r.errcode && l.errmsg == r.errmsg;
    }
    inline bool operator!=(const WXJSCodeToSessionRsp&l, const WXJSCodeToSessionRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const WXJSCodeToSessionRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,WXJSCodeToSessionRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetNewTicketReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetNewTicketReq";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        GetNewTicketReq()
        :wx_code("")
        {
        }
        void resetDefautlt()
        {
            wx_code = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(wx_code, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(wx_code, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["wx_code"] = tars::JsonOutput::writeJson(wx_code);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(wx_code,pObj->value["wx_code"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(wx_code,"wx_code");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(wx_code, false);
            return _os;
        }
    public:
        std::string wx_code;
    };
    inline bool operator==(const GetNewTicketReq&l, const GetNewTicketReq&r)
    {
        return l.wx_code == r.wx_code;
    }
    inline bool operator!=(const GetNewTicketReq&l, const GetNewTicketReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetNewTicketReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetNewTicketReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetNewTicketRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetNewTicketRsp";
        }
        static string MD5()
        {
            return "d42e5716eca49c942897abfb5af8d00f";
        }
        GetNewTicketRsp()
        :ret(0),errmsg(""),st("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
            st = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
            _os.write(st, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
            _is.read(st, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            p->value["st"] = tars::JsonOutput::writeJson(st);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
            tars::JsonInput::readJson(st,pObj->value["st"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            _ds.display(st,"st");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(st, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
        std::string st;
    };
    inline bool operator==(const GetNewTicketRsp&l, const GetNewTicketRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg && l.st == r.st;
    }
    inline bool operator!=(const GetNewTicketRsp&l, const GetNewTicketRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetNewTicketRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetNewTicketRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetNewTicketReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetNewTicketReq";
        }
        static string MD5()
        {
            return "5aec25c8786137819bcf5ec4b4d2c222";
        }
        ProxyGetNewTicketReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::GetNewTicketReq body;
    };
    inline bool operator==(const ProxyGetNewTicketReq&l, const ProxyGetNewTicketReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetNewTicketReq&l, const ProxyGetNewTicketReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetNewTicketReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetNewTicketReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetNewTicketRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetNewTicketRsp";
        }
        static string MD5()
        {
            return "928d4e1b43cbba9bb288e2656f572750";
        }
        ProxyGetNewTicketRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::GetNewTicketRsp body;
    };
    inline bool operator==(const ProxyGetNewTicketRsp&l, const ProxyGetNewTicketRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetNewTicketRsp&l, const ProxyGetNewTicketRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetNewTicketRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetNewTicketRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetNewCookieReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetNewCookieReq";
        }
        static string MD5()
        {
            return "325d87d477a8cf7a6468ed6bb39da964";
        }
        GetNewCookieReq()
        :userName(""),password("")
        {
        }
        void resetDefautlt()
        {
            userName = "";
            password = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(userName, 0);
            _os.write(password, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(userName, 0, true);
            _is.read(password, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["userName"] = tars::JsonOutput::writeJson(userName);
            p->value["password"] = tars::JsonOutput::writeJson(password);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(userName,pObj->value["userName"], true);
            tars::JsonInput::readJson(password,pObj->value["password"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(userName,"userName");
            _ds.display(password,"password");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(userName, true);
            _ds.displaySimple(password, false);
            return _os;
        }
    public:
        std::string userName;
        std::string password;
    };
    inline bool operator==(const GetNewCookieReq&l, const GetNewCookieReq&r)
    {
        return l.userName == r.userName && l.password == r.password;
    }
    inline bool operator!=(const GetNewCookieReq&l, const GetNewCookieReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetNewCookieReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetNewCookieReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetNewCookieRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetNewCookieRsp";
        }
        static string MD5()
        {
            return "d42e5716eca49c942897abfb5af8d00f";
        }
        GetNewCookieRsp()
        :ret(0),errmsg(""),st("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
            st = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
            _os.write(st, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
            _is.read(st, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            p->value["st"] = tars::JsonOutput::writeJson(st);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
            tars::JsonInput::readJson(st,pObj->value["st"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            _ds.display(st,"st");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(st, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
        std::string st;
    };
    inline bool operator==(const GetNewCookieRsp&l, const GetNewCookieRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg && l.st == r.st;
    }
    inline bool operator!=(const GetNewCookieRsp&l, const GetNewCookieRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetNewCookieRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetNewCookieRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetNewCookieReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetNewCookieReq";
        }
        static string MD5()
        {
            return "07dfb6ffc3f65060bea43e0ebd945498";
        }
        ProxyGetNewCookieReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::GetNewCookieReq body;
    };
    inline bool operator==(const ProxyGetNewCookieReq&l, const ProxyGetNewCookieReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetNewCookieReq&l, const ProxyGetNewCookieReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetNewCookieReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetNewCookieReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetNewCookieRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetNewCookieRsp";
        }
        static string MD5()
        {
            return "a855b68e452756aa4ea3ea104724723f";
        }
        ProxyGetNewCookieRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::GetNewCookieRsp body;
    };
    inline bool operator==(const ProxyGetNewCookieRsp&l, const ProxyGetNewCookieRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetNewCookieRsp&l, const ProxyGetNewCookieRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetNewCookieRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetNewCookieRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetCategoryListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetCategoryListReq";
        }
        static string MD5()
        {
            return "7b010a6336d210a506b1eb4bf4c1e014";
        }
        GetCategoryListReq()
        :level(0)
        {
        }
        void resetDefautlt()
        {
            level = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (level != 0)
            {
                _os.write(level, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(level, 0, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["level"] = tars::JsonOutput::writeJson(level);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(level,pObj->value["level"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(level,"level");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(level, false);
            return _os;
        }
    public:
        tars::Int32 level;
    };
    inline bool operator==(const GetCategoryListReq&l, const GetCategoryListReq&r)
    {
        return l.level == r.level;
    }
    inline bool operator!=(const GetCategoryListReq&l, const GetCategoryListReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetCategoryListReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetCategoryListReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct CategoryItem : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.CategoryItem";
        }
        static string MD5()
        {
            return "cd0e3323440d8e19750e7bba7062bba4";
        }
        CategoryItem()
        :categoryId(0),categoryName(""),parentId(0),level(0),imgUrl(""),desc("")
        {
        }
        void resetDefautlt()
        {
            categoryId = 0;
            categoryName = "";
            parentId = 0;
            level = 0;
            imgUrl = "";
            desc = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(categoryId, 0);
            _os.write(categoryName, 1);
            _os.write(parentId, 2);
            _os.write(level, 3);
            _os.write(imgUrl, 4);
            _os.write(desc, 5);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(categoryId, 0, true);
            _is.read(categoryName, 1, true);
            _is.read(parentId, 2, true);
            _is.read(level, 3, true);
            _is.read(imgUrl, 4, true);
            _is.read(desc, 5, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["categoryId"] = tars::JsonOutput::writeJson(categoryId);
            p->value["categoryName"] = tars::JsonOutput::writeJson(categoryName);
            p->value["parentId"] = tars::JsonOutput::writeJson(parentId);
            p->value["level"] = tars::JsonOutput::writeJson(level);
            p->value["imgUrl"] = tars::JsonOutput::writeJson(imgUrl);
            p->value["desc"] = tars::JsonOutput::writeJson(desc);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(categoryId,pObj->value["categoryId"], true);
            tars::JsonInput::readJson(categoryName,pObj->value["categoryName"], true);
            tars::JsonInput::readJson(parentId,pObj->value["parentId"], true);
            tars::JsonInput::readJson(level,pObj->value["level"], true);
            tars::JsonInput::readJson(imgUrl,pObj->value["imgUrl"], true);
            tars::JsonInput::readJson(desc,pObj->value["desc"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(categoryId,"categoryId");
            _ds.display(categoryName,"categoryName");
            _ds.display(parentId,"parentId");
            _ds.display(level,"level");
            _ds.display(imgUrl,"imgUrl");
            _ds.display(desc,"desc");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(categoryId, true);
            _ds.displaySimple(categoryName, true);
            _ds.displaySimple(parentId, true);
            _ds.displaySimple(level, true);
            _ds.displaySimple(imgUrl, true);
            _ds.displaySimple(desc, false);
            return _os;
        }
    public:
        tars::Int32 categoryId;
        std::string categoryName;
        tars::Int32 parentId;
        tars::Int32 level;
        std::string imgUrl;
        std::string desc;
    };
    inline bool operator==(const CategoryItem&l, const CategoryItem&r)
    {
        return l.categoryId == r.categoryId && l.categoryName == r.categoryName && l.parentId == r.parentId && l.level == r.level && l.imgUrl == r.imgUrl && l.desc == r.desc;
    }
    inline bool operator!=(const CategoryItem&l, const CategoryItem&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const CategoryItem&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,CategoryItem&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetCategoryListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetCategoryListRsp";
        }
        static string MD5()
        {
            return "402f4a336f3db87bfa4a3b4060fcd56a";
        }
        GetCategoryListRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
            _os.write(mpCategory, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
            _is.read(mpCategory, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            p->value["mpCategory"] = tars::JsonOutput::writeJson(mpCategory);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
            tars::JsonInput::readJson(mpCategory,pObj->value["mpCategory"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            _ds.display(mpCategory,"mpCategory");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(mpCategory, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
        map<tars::Int32, vector<HardwareApplet::CategoryItem> > mpCategory;
    };
    inline bool operator==(const GetCategoryListRsp&l, const GetCategoryListRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg && l.mpCategory == r.mpCategory;
    }
    inline bool operator!=(const GetCategoryListRsp&l, const GetCategoryListRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetCategoryListRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetCategoryListRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetCategoryListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetCategoryListReq";
        }
        static string MD5()
        {
            return "ad5f5a432653fdc4cc2b31035451431d";
        }
        ProxyGetCategoryListReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::GetCategoryListReq body;
    };
    inline bool operator==(const ProxyGetCategoryListReq&l, const ProxyGetCategoryListReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetCategoryListReq&l, const ProxyGetCategoryListReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetCategoryListReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetCategoryListReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetCategoryListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetCategoryListRsp";
        }
        static string MD5()
        {
            return "39250fe13d2d375e76b22e1c4b6f2f39";
        }
        ProxyGetCategoryListRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::GetCategoryListRsp body;
    };
    inline bool operator==(const ProxyGetCategoryListRsp&l, const ProxyGetCategoryListRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetCategoryListRsp&l, const ProxyGetCategoryListRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetCategoryListRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetCategoryListRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AddCategoryInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AddCategoryInfoReq";
        }
        static string MD5()
        {
            return "a5fc8bd7d76ea8a43f734c2295fb0b33";
        }
        AddCategoryInfoReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(item, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(item, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["item"] = tars::JsonOutput::writeJson(item);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(item,pObj->value["item"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(item,"item");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(item, false);
            return _os;
        }
    public:
        HardwareApplet::CategoryItem item;
    };
    inline bool operator==(const AddCategoryInfoReq&l, const AddCategoryInfoReq&r)
    {
        return l.item == r.item;
    }
    inline bool operator!=(const AddCategoryInfoReq&l, const AddCategoryInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AddCategoryInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AddCategoryInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AddCategoryInfoRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AddCategoryInfoRsp";
        }
        static string MD5()
        {
            return "b84e4dd5dd1d7c43dbe702512024405f";
        }
        AddCategoryInfoRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
    };
    inline bool operator==(const AddCategoryInfoRsp&l, const AddCategoryInfoRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg;
    }
    inline bool operator!=(const AddCategoryInfoRsp&l, const AddCategoryInfoRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AddCategoryInfoRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AddCategoryInfoRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyAddCategoryInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyAddCategoryInfoReq";
        }
        static string MD5()
        {
            return "7d294fcdefd89fdd707595e74017acbd";
        }
        ProxyAddCategoryInfoReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::AddCategoryInfoReq body;
    };
    inline bool operator==(const ProxyAddCategoryInfoReq&l, const ProxyAddCategoryInfoReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyAddCategoryInfoReq&l, const ProxyAddCategoryInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyAddCategoryInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyAddCategoryInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyAddCategoryInfoRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyAddCategoryInfoRsp";
        }
        static string MD5()
        {
            return "18e4e73c990bc7b224654cf0b6547d7b";
        }
        ProxyAddCategoryInfoRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::AddCategoryInfoRsp body;
    };
    inline bool operator==(const ProxyAddCategoryInfoRsp&l, const ProxyAddCategoryInfoRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyAddCategoryInfoRsp&l, const ProxyAddCategoryInfoRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyAddCategoryInfoRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyAddCategoryInfoRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetAttributeListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetAttributeListReq";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        GetAttributeListReq()
        :reserved_field("")
        {
        }
        void resetDefautlt()
        {
            reserved_field = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (reserved_field != "")
            {
                _os.write(reserved_field, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(reserved_field, 0, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["reserved_field"] = tars::JsonOutput::writeJson(reserved_field);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(reserved_field,pObj->value["reserved_field"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(reserved_field,"reserved_field");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(reserved_field, false);
            return _os;
        }
    public:
        std::string reserved_field;
    };
    inline bool operator==(const GetAttributeListReq&l, const GetAttributeListReq&r)
    {
        return l.reserved_field == r.reserved_field;
    }
    inline bool operator!=(const GetAttributeListReq&l, const GetAttributeListReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetAttributeListReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetAttributeListReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AttributeItem : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AttributeItem";
        }
        static string MD5()
        {
            return "d42e5716eca49c942897abfb5af8d00f";
        }
        AttributeItem()
        :attrId(0),attrName(""),attrDesc("")
        {
        }
        void resetDefautlt()
        {
            attrId = 0;
            attrName = "";
            attrDesc = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(attrId, 0);
            _os.write(attrName, 1);
            _os.write(attrDesc, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(attrId, 0, true);
            _is.read(attrName, 1, true);
            _is.read(attrDesc, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["attrId"] = tars::JsonOutput::writeJson(attrId);
            p->value["attrName"] = tars::JsonOutput::writeJson(attrName);
            p->value["attrDesc"] = tars::JsonOutput::writeJson(attrDesc);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(attrId,pObj->value["attrId"], true);
            tars::JsonInput::readJson(attrName,pObj->value["attrName"], true);
            tars::JsonInput::readJson(attrDesc,pObj->value["attrDesc"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(attrId,"attrId");
            _ds.display(attrName,"attrName");
            _ds.display(attrDesc,"attrDesc");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(attrId, true);
            _ds.displaySimple(attrName, true);
            _ds.displaySimple(attrDesc, false);
            return _os;
        }
    public:
        tars::Int32 attrId;
        std::string attrName;
        std::string attrDesc;
    };
    inline bool operator==(const AttributeItem&l, const AttributeItem&r)
    {
        return l.attrId == r.attrId && l.attrName == r.attrName && l.attrDesc == r.attrDesc;
    }
    inline bool operator!=(const AttributeItem&l, const AttributeItem&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AttributeItem&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AttributeItem&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetAttributeListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetAttributeListRsp";
        }
        static string MD5()
        {
            return "97e936004355ba4da35e754dffdce07d";
        }
        GetAttributeListRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
            _os.write(itemList, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
            _is.read(itemList, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            p->value["itemList"] = tars::JsonOutput::writeJson(itemList);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
            tars::JsonInput::readJson(itemList,pObj->value["itemList"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            _ds.display(itemList,"itemList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(itemList, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
        vector<HardwareApplet::AttributeItem> itemList;
    };
    inline bool operator==(const GetAttributeListRsp&l, const GetAttributeListRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg && l.itemList == r.itemList;
    }
    inline bool operator!=(const GetAttributeListRsp&l, const GetAttributeListRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetAttributeListRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetAttributeListRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetAttributeListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetAttributeListReq";
        }
        static string MD5()
        {
            return "b7a73abd97225c9ec4a583971c59cbca";
        }
        ProxyGetAttributeListReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::GetAttributeListReq body;
    };
    inline bool operator==(const ProxyGetAttributeListReq&l, const ProxyGetAttributeListReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetAttributeListReq&l, const ProxyGetAttributeListReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetAttributeListReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetAttributeListReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetAttributeListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetAttributeListRsp";
        }
        static string MD5()
        {
            return "dbf5ca4dfbea34e7e30133ca10279d0d";
        }
        ProxyGetAttributeListRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::GetAttributeListRsp body;
    };
    inline bool operator==(const ProxyGetAttributeListRsp&l, const ProxyGetAttributeListRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetAttributeListRsp&l, const ProxyGetAttributeListRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetAttributeListRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetAttributeListRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AddAttributeInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AddAttributeInfoReq";
        }
        static string MD5()
        {
            return "3b48c4a64281f9123280dee4302a0ab8";
        }
        AddAttributeInfoReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(item, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(item, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["item"] = tars::JsonOutput::writeJson(item);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(item,pObj->value["item"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(item,"item");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(item, false);
            return _os;
        }
    public:
        HardwareApplet::AttributeItem item;
    };
    inline bool operator==(const AddAttributeInfoReq&l, const AddAttributeInfoReq&r)
    {
        return l.item == r.item;
    }
    inline bool operator!=(const AddAttributeInfoReq&l, const AddAttributeInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AddAttributeInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AddAttributeInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AddAttributeInfoRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AddAttributeInfoRsp";
        }
        static string MD5()
        {
            return "b84e4dd5dd1d7c43dbe702512024405f";
        }
        AddAttributeInfoRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
    };
    inline bool operator==(const AddAttributeInfoRsp&l, const AddAttributeInfoRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg;
    }
    inline bool operator!=(const AddAttributeInfoRsp&l, const AddAttributeInfoRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AddAttributeInfoRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AddAttributeInfoRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyAddAttributeInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyAddAttributeInfoReq";
        }
        static string MD5()
        {
            return "e2869cb97d01e4b69527d49604e3e4d5";
        }
        ProxyAddAttributeInfoReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::AddAttributeInfoReq body;
    };
    inline bool operator==(const ProxyAddAttributeInfoReq&l, const ProxyAddAttributeInfoReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyAddAttributeInfoReq&l, const ProxyAddAttributeInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyAddAttributeInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyAddAttributeInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyAddAttributeInfoRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyAddAttributeInfoRsp";
        }
        static string MD5()
        {
            return "b81fa37b2e9d18e4f6a7c7eaff80af4c";
        }
        ProxyAddAttributeInfoRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::AddAttributeInfoRsp body;
    };
    inline bool operator==(const ProxyAddAttributeInfoRsp&l, const ProxyAddAttributeInfoRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyAddAttributeInfoRsp&l, const ProxyAddAttributeInfoRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyAddAttributeInfoRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyAddAttributeInfoRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetAttributeValueListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetAttributeValueListReq";
        }
        static string MD5()
        {
            return "7b010a6336d210a506b1eb4bf4c1e014";
        }
        GetAttributeValueListReq()
        :attrId(0)
        {
        }
        void resetDefautlt()
        {
            attrId = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (attrId != 0)
            {
                _os.write(attrId, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(attrId, 0, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["attrId"] = tars::JsonOutput::writeJson(attrId);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(attrId,pObj->value["attrId"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(attrId,"attrId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(attrId, false);
            return _os;
        }
    public:
        tars::Int32 attrId;
    };
    inline bool operator==(const GetAttributeValueListReq&l, const GetAttributeValueListReq&r)
    {
        return l.attrId == r.attrId;
    }
    inline bool operator!=(const GetAttributeValueListReq&l, const GetAttributeValueListReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetAttributeValueListReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetAttributeValueListReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AttributeValueItem : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AttributeValueItem";
        }
        static string MD5()
        {
            return "b1b405ff7377dd094bb2b1d7b527fd45";
        }
        AttributeValueItem()
        :attrValueId(0),name(""),attrId(0)
        {
        }
        void resetDefautlt()
        {
            attrValueId = 0;
            name = "";
            attrId = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(attrValueId, 0);
            _os.write(name, 1);
            _os.write(attrId, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(attrValueId, 0, true);
            _is.read(name, 1, true);
            _is.read(attrId, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["attrValueId"] = tars::JsonOutput::writeJson(attrValueId);
            p->value["name"] = tars::JsonOutput::writeJson(name);
            p->value["attrId"] = tars::JsonOutput::writeJson(attrId);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(attrValueId,pObj->value["attrValueId"], true);
            tars::JsonInput::readJson(name,pObj->value["name"], true);
            tars::JsonInput::readJson(attrId,pObj->value["attrId"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(attrValueId,"attrValueId");
            _ds.display(name,"name");
            _ds.display(attrId,"attrId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(attrValueId, true);
            _ds.displaySimple(name, true);
            _ds.displaySimple(attrId, false);
            return _os;
        }
    public:
        tars::Int32 attrValueId;
        std::string name;
        tars::Int32 attrId;
    };
    inline bool operator==(const AttributeValueItem&l, const AttributeValueItem&r)
    {
        return l.attrValueId == r.attrValueId && l.name == r.name && l.attrId == r.attrId;
    }
    inline bool operator!=(const AttributeValueItem&l, const AttributeValueItem&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AttributeValueItem&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AttributeValueItem&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetAttributeValueListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetAttributeValueListRsp";
        }
        static string MD5()
        {
            return "cbcb365bbadd0c359572bbd7ffe1003a";
        }
        GetAttributeValueListRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
            _os.write(mpAttrValue, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
            _is.read(mpAttrValue, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            p->value["mpAttrValue"] = tars::JsonOutput::writeJson(mpAttrValue);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
            tars::JsonInput::readJson(mpAttrValue,pObj->value["mpAttrValue"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            _ds.display(mpAttrValue,"mpAttrValue");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(mpAttrValue, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
        map<tars::Int32, vector<HardwareApplet::AttributeValueItem> > mpAttrValue;
    };
    inline bool operator==(const GetAttributeValueListRsp&l, const GetAttributeValueListRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg && l.mpAttrValue == r.mpAttrValue;
    }
    inline bool operator!=(const GetAttributeValueListRsp&l, const GetAttributeValueListRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetAttributeValueListRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetAttributeValueListRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetAttributeValueListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetAttributeValueListReq";
        }
        static string MD5()
        {
            return "06b7c1ce7ee4aa75dbb4e280bc1df6a2";
        }
        ProxyGetAttributeValueListReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::GetAttributeValueListReq body;
    };
    inline bool operator==(const ProxyGetAttributeValueListReq&l, const ProxyGetAttributeValueListReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetAttributeValueListReq&l, const ProxyGetAttributeValueListReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetAttributeValueListReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetAttributeValueListReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetAttributeValueListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetAttributeValueListRsp";
        }
        static string MD5()
        {
            return "9e9ec179941142659cf85c5bffafb7dd";
        }
        ProxyGetAttributeValueListRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::GetAttributeValueListRsp body;
    };
    inline bool operator==(const ProxyGetAttributeValueListRsp&l, const ProxyGetAttributeValueListRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetAttributeValueListRsp&l, const ProxyGetAttributeValueListRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetAttributeValueListRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetAttributeValueListRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AddAttributeValueInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AddAttributeValueInfoReq";
        }
        static string MD5()
        {
            return "b5de64396547de602ee81bfcb89235f7";
        }
        AddAttributeValueInfoReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(item, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(item, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["item"] = tars::JsonOutput::writeJson(item);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(item,pObj->value["item"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(item,"item");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(item, false);
            return _os;
        }
    public:
        HardwareApplet::AttributeValueItem item;
    };
    inline bool operator==(const AddAttributeValueInfoReq&l, const AddAttributeValueInfoReq&r)
    {
        return l.item == r.item;
    }
    inline bool operator!=(const AddAttributeValueInfoReq&l, const AddAttributeValueInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AddAttributeValueInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AddAttributeValueInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AddAttributeValueInfoRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AddAttributeValueInfoRsp";
        }
        static string MD5()
        {
            return "b84e4dd5dd1d7c43dbe702512024405f";
        }
        AddAttributeValueInfoRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
    };
    inline bool operator==(const AddAttributeValueInfoRsp&l, const AddAttributeValueInfoRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg;
    }
    inline bool operator!=(const AddAttributeValueInfoRsp&l, const AddAttributeValueInfoRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AddAttributeValueInfoRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AddAttributeValueInfoRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyAddAttributeValueInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyAddAttributeValueInfoReq";
        }
        static string MD5()
        {
            return "5de250bf47328458e2804125686a8cae";
        }
        ProxyAddAttributeValueInfoReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::AddAttributeValueInfoReq body;
    };
    inline bool operator==(const ProxyAddAttributeValueInfoReq&l, const ProxyAddAttributeValueInfoReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyAddAttributeValueInfoReq&l, const ProxyAddAttributeValueInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyAddAttributeValueInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyAddAttributeValueInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyAddAttributeValueInfoRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyAddAttributeValueInfoRsp";
        }
        static string MD5()
        {
            return "14646d95d0e2b62cc51dd42ab5485537";
        }
        ProxyAddAttributeValueInfoRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::AddAttributeValueInfoRsp body;
    };
    inline bool operator==(const ProxyAddAttributeValueInfoRsp&l, const ProxyAddAttributeValueInfoRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyAddAttributeValueInfoRsp&l, const ProxyAddAttributeValueInfoRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyAddAttributeValueInfoRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyAddAttributeValueInfoRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetBrandListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetBrandListReq";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        GetBrandListReq()
        :reserved_field("")
        {
        }
        void resetDefautlt()
        {
            reserved_field = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (reserved_field != "")
            {
                _os.write(reserved_field, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(reserved_field, 0, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["reserved_field"] = tars::JsonOutput::writeJson(reserved_field);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(reserved_field,pObj->value["reserved_field"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(reserved_field,"reserved_field");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(reserved_field, false);
            return _os;
        }
    public:
        std::string reserved_field;
    };
    inline bool operator==(const GetBrandListReq&l, const GetBrandListReq&r)
    {
        return l.reserved_field == r.reserved_field;
    }
    inline bool operator!=(const GetBrandListReq&l, const GetBrandListReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetBrandListReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetBrandListReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct BrandItem : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.BrandItem";
        }
        static string MD5()
        {
            return "d42e5716eca49c942897abfb5af8d00f";
        }
        BrandItem()
        :brandId(0),brandName(""),brandDesc("")
        {
        }
        void resetDefautlt()
        {
            brandId = 0;
            brandName = "";
            brandDesc = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(brandId, 0);
            _os.write(brandName, 1);
            _os.write(brandDesc, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(brandId, 0, true);
            _is.read(brandName, 1, true);
            _is.read(brandDesc, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["brandId"] = tars::JsonOutput::writeJson(brandId);
            p->value["brandName"] = tars::JsonOutput::writeJson(brandName);
            p->value["brandDesc"] = tars::JsonOutput::writeJson(brandDesc);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(brandId,pObj->value["brandId"], true);
            tars::JsonInput::readJson(brandName,pObj->value["brandName"], true);
            tars::JsonInput::readJson(brandDesc,pObj->value["brandDesc"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(brandId,"brandId");
            _ds.display(brandName,"brandName");
            _ds.display(brandDesc,"brandDesc");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(brandId, true);
            _ds.displaySimple(brandName, true);
            _ds.displaySimple(brandDesc, false);
            return _os;
        }
    public:
        tars::Int32 brandId;
        std::string brandName;
        std::string brandDesc;
    };
    inline bool operator==(const BrandItem&l, const BrandItem&r)
    {
        return l.brandId == r.brandId && l.brandName == r.brandName && l.brandDesc == r.brandDesc;
    }
    inline bool operator!=(const BrandItem&l, const BrandItem&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const BrandItem&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,BrandItem&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetBrandListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetBrandListRsp";
        }
        static string MD5()
        {
            return "5fc5360a95658b3fc0195153138299e6";
        }
        GetBrandListRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
            _os.write(itemList, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
            _is.read(itemList, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            p->value["itemList"] = tars::JsonOutput::writeJson(itemList);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
            tars::JsonInput::readJson(itemList,pObj->value["itemList"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            _ds.display(itemList,"itemList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(itemList, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
        vector<HardwareApplet::BrandItem> itemList;
    };
    inline bool operator==(const GetBrandListRsp&l, const GetBrandListRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg && l.itemList == r.itemList;
    }
    inline bool operator!=(const GetBrandListRsp&l, const GetBrandListRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetBrandListRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetBrandListRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetBrandListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetBrandListReq";
        }
        static string MD5()
        {
            return "251ff9288cc6f251631c46636fe09044";
        }
        ProxyGetBrandListReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::GetBrandListReq body;
    };
    inline bool operator==(const ProxyGetBrandListReq&l, const ProxyGetBrandListReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetBrandListReq&l, const ProxyGetBrandListReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetBrandListReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetBrandListReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetBrandListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetBrandListRsp";
        }
        static string MD5()
        {
            return "43ad6fc22c3713e788bba3f16f03381b";
        }
        ProxyGetBrandListRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::GetBrandListRsp body;
    };
    inline bool operator==(const ProxyGetBrandListRsp&l, const ProxyGetBrandListRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetBrandListRsp&l, const ProxyGetBrandListRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetBrandListRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetBrandListRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AddBrandInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AddBrandInfoReq";
        }
        static string MD5()
        {
            return "f4d907609e8b0b0f7fb4c711af476106";
        }
        AddBrandInfoReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(item, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(item, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["item"] = tars::JsonOutput::writeJson(item);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(item,pObj->value["item"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(item,"item");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(item, false);
            return _os;
        }
    public:
        HardwareApplet::BrandItem item;
    };
    inline bool operator==(const AddBrandInfoReq&l, const AddBrandInfoReq&r)
    {
        return l.item == r.item;
    }
    inline bool operator!=(const AddBrandInfoReq&l, const AddBrandInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AddBrandInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AddBrandInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AddBrandInfoRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AddBrandInfoRsp";
        }
        static string MD5()
        {
            return "b84e4dd5dd1d7c43dbe702512024405f";
        }
        AddBrandInfoRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
    };
    inline bool operator==(const AddBrandInfoRsp&l, const AddBrandInfoRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg;
    }
    inline bool operator!=(const AddBrandInfoRsp&l, const AddBrandInfoRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AddBrandInfoRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AddBrandInfoRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyAddBrandInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyAddBrandInfoReq";
        }
        static string MD5()
        {
            return "5b95aec9d0f037b8c31940eb2ebb01bf";
        }
        ProxyAddBrandInfoReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::AddBrandInfoReq body;
    };
    inline bool operator==(const ProxyAddBrandInfoReq&l, const ProxyAddBrandInfoReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyAddBrandInfoReq&l, const ProxyAddBrandInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyAddBrandInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyAddBrandInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyAddBrandInfoRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyAddBrandInfoRsp";
        }
        static string MD5()
        {
            return "0b0b26b9b19bdae75a32fabf619a8ef8";
        }
        ProxyAddBrandInfoRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::AddBrandInfoRsp body;
    };
    inline bool operator==(const ProxyAddBrandInfoRsp&l, const ProxyAddBrandInfoRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyAddBrandInfoRsp&l, const ProxyAddBrandInfoRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyAddBrandInfoRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyAddBrandInfoRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetMakerListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetMakerListReq";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        GetMakerListReq()
        :reserved_field("")
        {
        }
        void resetDefautlt()
        {
            reserved_field = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (reserved_field != "")
            {
                _os.write(reserved_field, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(reserved_field, 0, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["reserved_field"] = tars::JsonOutput::writeJson(reserved_field);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(reserved_field,pObj->value["reserved_field"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(reserved_field,"reserved_field");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(reserved_field, false);
            return _os;
        }
    public:
        std::string reserved_field;
    };
    inline bool operator==(const GetMakerListReq&l, const GetMakerListReq&r)
    {
        return l.reserved_field == r.reserved_field;
    }
    inline bool operator!=(const GetMakerListReq&l, const GetMakerListReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetMakerListReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetMakerListReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct MakerItem : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.MakerItem";
        }
        static string MD5()
        {
            return "d42e5716eca49c942897abfb5af8d00f";
        }
        MakerItem()
        :makerId(0),makerName(""),makerDesc("")
        {
        }
        void resetDefautlt()
        {
            makerId = 0;
            makerName = "";
            makerDesc = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(makerId, 0);
            _os.write(makerName, 1);
            _os.write(makerDesc, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(makerId, 0, true);
            _is.read(makerName, 1, true);
            _is.read(makerDesc, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["makerId"] = tars::JsonOutput::writeJson(makerId);
            p->value["makerName"] = tars::JsonOutput::writeJson(makerName);
            p->value["makerDesc"] = tars::JsonOutput::writeJson(makerDesc);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(makerId,pObj->value["makerId"], true);
            tars::JsonInput::readJson(makerName,pObj->value["makerName"], true);
            tars::JsonInput::readJson(makerDesc,pObj->value["makerDesc"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(makerId,"makerId");
            _ds.display(makerName,"makerName");
            _ds.display(makerDesc,"makerDesc");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(makerId, true);
            _ds.displaySimple(makerName, true);
            _ds.displaySimple(makerDesc, false);
            return _os;
        }
    public:
        tars::Int32 makerId;
        std::string makerName;
        std::string makerDesc;
    };
    inline bool operator==(const MakerItem&l, const MakerItem&r)
    {
        return l.makerId == r.makerId && l.makerName == r.makerName && l.makerDesc == r.makerDesc;
    }
    inline bool operator!=(const MakerItem&l, const MakerItem&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const MakerItem&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,MakerItem&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetMakerListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetMakerListRsp";
        }
        static string MD5()
        {
            return "462b86615999d87e62b7a5e83adbe4d2";
        }
        GetMakerListRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
            _os.write(itemList, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
            _is.read(itemList, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            p->value["itemList"] = tars::JsonOutput::writeJson(itemList);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
            tars::JsonInput::readJson(itemList,pObj->value["itemList"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            _ds.display(itemList,"itemList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(itemList, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
        vector<HardwareApplet::MakerItem> itemList;
    };
    inline bool operator==(const GetMakerListRsp&l, const GetMakerListRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg && l.itemList == r.itemList;
    }
    inline bool operator!=(const GetMakerListRsp&l, const GetMakerListRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetMakerListRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetMakerListRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetMakerListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetMakerListReq";
        }
        static string MD5()
        {
            return "68c28f9eaca4b5ec6add97f1c460a57b";
        }
        ProxyGetMakerListReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::GetMakerListReq body;
    };
    inline bool operator==(const ProxyGetMakerListReq&l, const ProxyGetMakerListReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetMakerListReq&l, const ProxyGetMakerListReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetMakerListReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetMakerListReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetMakerListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetMakerListRsp";
        }
        static string MD5()
        {
            return "7ef46e744596154c06cd791fb89905fc";
        }
        ProxyGetMakerListRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::GetMakerListRsp body;
    };
    inline bool operator==(const ProxyGetMakerListRsp&l, const ProxyGetMakerListRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetMakerListRsp&l, const ProxyGetMakerListRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetMakerListRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetMakerListRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AddMakerInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AddMakerInfoReq";
        }
        static string MD5()
        {
            return "5e1ac45891ca559ea1639051cd0f96f7";
        }
        AddMakerInfoReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(item, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(item, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["item"] = tars::JsonOutput::writeJson(item);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(item,pObj->value["item"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(item,"item");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(item, false);
            return _os;
        }
    public:
        HardwareApplet::MakerItem item;
    };
    inline bool operator==(const AddMakerInfoReq&l, const AddMakerInfoReq&r)
    {
        return l.item == r.item;
    }
    inline bool operator!=(const AddMakerInfoReq&l, const AddMakerInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AddMakerInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AddMakerInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AddMakerInfoRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AddMakerInfoRsp";
        }
        static string MD5()
        {
            return "b84e4dd5dd1d7c43dbe702512024405f";
        }
        AddMakerInfoRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
    };
    inline bool operator==(const AddMakerInfoRsp&l, const AddMakerInfoRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg;
    }
    inline bool operator!=(const AddMakerInfoRsp&l, const AddMakerInfoRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AddMakerInfoRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AddMakerInfoRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyAddMakerInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyAddMakerInfoReq";
        }
        static string MD5()
        {
            return "5e09a35f9b9f921d8532f9012e8c854a";
        }
        ProxyAddMakerInfoReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::AddMakerInfoReq body;
    };
    inline bool operator==(const ProxyAddMakerInfoReq&l, const ProxyAddMakerInfoReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyAddMakerInfoReq&l, const ProxyAddMakerInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyAddMakerInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyAddMakerInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyAddMakerInfoRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyAddMakerInfoRsp";
        }
        static string MD5()
        {
            return "234fd4dcb765950e22780c5a8a92f559";
        }
        ProxyAddMakerInfoRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::AddMakerInfoRsp body;
    };
    inline bool operator==(const ProxyAddMakerInfoRsp&l, const ProxyAddMakerInfoRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyAddMakerInfoRsp&l, const ProxyAddMakerInfoRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyAddMakerInfoRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyAddMakerInfoRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetWarehouseListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetWarehouseListReq";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        GetWarehouseListReq()
        :reserved_field("")
        {
        }
        void resetDefautlt()
        {
            reserved_field = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (reserved_field != "")
            {
                _os.write(reserved_field, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(reserved_field, 0, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["reserved_field"] = tars::JsonOutput::writeJson(reserved_field);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(reserved_field,pObj->value["reserved_field"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(reserved_field,"reserved_field");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(reserved_field, false);
            return _os;
        }
    public:
        std::string reserved_field;
    };
    inline bool operator==(const GetWarehouseListReq&l, const GetWarehouseListReq&r)
    {
        return l.reserved_field == r.reserved_field;
    }
    inline bool operator!=(const GetWarehouseListReq&l, const GetWarehouseListReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetWarehouseListReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetWarehouseListReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct WarehouseItem : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.WarehouseItem";
        }
        static string MD5()
        {
            return "d42e5716eca49c942897abfb5af8d00f";
        }
        WarehouseItem()
        :warehouseId(0),warehouseName(""),warehouseDesc("")
        {
        }
        void resetDefautlt()
        {
            warehouseId = 0;
            warehouseName = "";
            warehouseDesc = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(warehouseId, 0);
            _os.write(warehouseName, 1);
            _os.write(warehouseDesc, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(warehouseId, 0, true);
            _is.read(warehouseName, 1, true);
            _is.read(warehouseDesc, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["warehouseId"] = tars::JsonOutput::writeJson(warehouseId);
            p->value["warehouseName"] = tars::JsonOutput::writeJson(warehouseName);
            p->value["warehouseDesc"] = tars::JsonOutput::writeJson(warehouseDesc);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(warehouseId,pObj->value["warehouseId"], true);
            tars::JsonInput::readJson(warehouseName,pObj->value["warehouseName"], true);
            tars::JsonInput::readJson(warehouseDesc,pObj->value["warehouseDesc"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(warehouseId,"warehouseId");
            _ds.display(warehouseName,"warehouseName");
            _ds.display(warehouseDesc,"warehouseDesc");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(warehouseId, true);
            _ds.displaySimple(warehouseName, true);
            _ds.displaySimple(warehouseDesc, false);
            return _os;
        }
    public:
        tars::Int32 warehouseId;
        std::string warehouseName;
        std::string warehouseDesc;
    };
    inline bool operator==(const WarehouseItem&l, const WarehouseItem&r)
    {
        return l.warehouseId == r.warehouseId && l.warehouseName == r.warehouseName && l.warehouseDesc == r.warehouseDesc;
    }
    inline bool operator!=(const WarehouseItem&l, const WarehouseItem&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const WarehouseItem&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,WarehouseItem&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetWarehouseListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetWarehouseListRsp";
        }
        static string MD5()
        {
            return "d90bd6b6ced279b24d830a90918fc57e";
        }
        GetWarehouseListRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
            _os.write(itemList, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
            _is.read(itemList, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            p->value["itemList"] = tars::JsonOutput::writeJson(itemList);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
            tars::JsonInput::readJson(itemList,pObj->value["itemList"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            _ds.display(itemList,"itemList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(itemList, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
        vector<HardwareApplet::WarehouseItem> itemList;
    };
    inline bool operator==(const GetWarehouseListRsp&l, const GetWarehouseListRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg && l.itemList == r.itemList;
    }
    inline bool operator!=(const GetWarehouseListRsp&l, const GetWarehouseListRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetWarehouseListRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetWarehouseListRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetWarehouseListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetWarehouseListReq";
        }
        static string MD5()
        {
            return "0d454b20b3078539b76e81976679d947";
        }
        ProxyGetWarehouseListReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::GetWarehouseListReq body;
    };
    inline bool operator==(const ProxyGetWarehouseListReq&l, const ProxyGetWarehouseListReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetWarehouseListReq&l, const ProxyGetWarehouseListReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetWarehouseListReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetWarehouseListReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetWarehouseListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetWarehouseListRsp";
        }
        static string MD5()
        {
            return "24e99ec8dd43615a3580fbe27e2a87ce";
        }
        ProxyGetWarehouseListRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::GetWarehouseListRsp body;
    };
    inline bool operator==(const ProxyGetWarehouseListRsp&l, const ProxyGetWarehouseListRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetWarehouseListRsp&l, const ProxyGetWarehouseListRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetWarehouseListRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetWarehouseListRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AddWarehouseInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AddWarehouseInfoReq";
        }
        static string MD5()
        {
            return "f79851be72e7d6fdc7ece6b6db06557e";
        }
        AddWarehouseInfoReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(item, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(item, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["item"] = tars::JsonOutput::writeJson(item);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(item,pObj->value["item"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(item,"item");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(item, false);
            return _os;
        }
    public:
        HardwareApplet::WarehouseItem item;
    };
    inline bool operator==(const AddWarehouseInfoReq&l, const AddWarehouseInfoReq&r)
    {
        return l.item == r.item;
    }
    inline bool operator!=(const AddWarehouseInfoReq&l, const AddWarehouseInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AddWarehouseInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AddWarehouseInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AddWarehouseInfoRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AddWarehouseInfoRsp";
        }
        static string MD5()
        {
            return "b84e4dd5dd1d7c43dbe702512024405f";
        }
        AddWarehouseInfoRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
    };
    inline bool operator==(const AddWarehouseInfoRsp&l, const AddWarehouseInfoRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg;
    }
    inline bool operator!=(const AddWarehouseInfoRsp&l, const AddWarehouseInfoRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AddWarehouseInfoRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AddWarehouseInfoRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyAddWarehouseInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyAddWarehouseInfoReq";
        }
        static string MD5()
        {
            return "374636a2d8e70d0e2a877a1c0ce197d4";
        }
        ProxyAddWarehouseInfoReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::AddWarehouseInfoReq body;
    };
    inline bool operator==(const ProxyAddWarehouseInfoReq&l, const ProxyAddWarehouseInfoReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyAddWarehouseInfoReq&l, const ProxyAddWarehouseInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyAddWarehouseInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyAddWarehouseInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyAddWarehouseInfoRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyAddWarehouseInfoRsp";
        }
        static string MD5()
        {
            return "421df75dadf334f3988b6b1932fee3d8";
        }
        ProxyAddWarehouseInfoRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::AddWarehouseInfoRsp body;
    };
    inline bool operator==(const ProxyAddWarehouseInfoRsp&l, const ProxyAddWarehouseInfoRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyAddWarehouseInfoRsp&l, const ProxyAddWarehouseInfoRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyAddWarehouseInfoRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyAddWarehouseInfoRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GoodsMediaInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GoodsMediaInfo";
        }
        static string MD5()
        {
            return "6f5ea010fef30b29da23145d7a4e0bba";
        }
        GoodsMediaInfo()
        :mediaId(0),type(0),position(0),mediaUrl("")
        {
        }
        void resetDefautlt()
        {
            mediaId = 0;
            type = 0;
            position = 0;
            mediaUrl = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(mediaId, 0);
            _os.write(type, 1);
            _os.write(position, 2);
            _os.write(mediaUrl, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(mediaId, 0, true);
            _is.read(type, 1, true);
            _is.read(position, 2, true);
            _is.read(mediaUrl, 3, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["mediaId"] = tars::JsonOutput::writeJson(mediaId);
            p->value["type"] = tars::JsonOutput::writeJson(type);
            p->value["position"] = tars::JsonOutput::writeJson(position);
            p->value["mediaUrl"] = tars::JsonOutput::writeJson(mediaUrl);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(mediaId,pObj->value["mediaId"], true);
            tars::JsonInput::readJson(type,pObj->value["type"], true);
            tars::JsonInput::readJson(position,pObj->value["position"], true);
            tars::JsonInput::readJson(mediaUrl,pObj->value["mediaUrl"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(mediaId,"mediaId");
            _ds.display(type,"type");
            _ds.display(position,"position");
            _ds.display(mediaUrl,"mediaUrl");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(mediaId, true);
            _ds.displaySimple(type, true);
            _ds.displaySimple(position, true);
            _ds.displaySimple(mediaUrl, false);
            return _os;
        }
    public:
        tars::Int32 mediaId;
        tars::Int32 type;
        tars::Int32 position;
        std::string mediaUrl;
    };
    inline bool operator==(const GoodsMediaInfo&l, const GoodsMediaInfo&r)
    {
        return l.mediaId == r.mediaId && l.type == r.type && l.position == r.position && l.mediaUrl == r.mediaUrl;
    }
    inline bool operator!=(const GoodsMediaInfo&l, const GoodsMediaInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GoodsMediaInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GoodsMediaInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GoodsSPUSimpleInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GoodsSPUSimpleInfo";
        }
        static string MD5()
        {
            return "92fc11707a3f1a925f6754d9089d46a6";
        }
        GoodsSPUSimpleInfo()
        :spuId(0),name(""),brandName(""),maker(""),sDesc(""),status(-1)
        {
        }
        void resetDefautlt()
        {
            spuId = 0;
            name = "";
            brandName = "";
            maker = "";
            sDesc = "";
            status = -1;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(spuId, 0);
            _os.write(name, 1);
            _os.write(brandName, 2);
            _os.write(maker, 3);
            _os.write(sDesc, 4);
            _os.write(status, 5);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(spuId, 0, true);
            _is.read(name, 1, true);
            _is.read(brandName, 2, true);
            _is.read(maker, 3, true);
            _is.read(sDesc, 4, true);
            _is.read(status, 5, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["spuId"] = tars::JsonOutput::writeJson(spuId);
            p->value["name"] = tars::JsonOutput::writeJson(name);
            p->value["brandName"] = tars::JsonOutput::writeJson(brandName);
            p->value["maker"] = tars::JsonOutput::writeJson(maker);
            p->value["sDesc"] = tars::JsonOutput::writeJson(sDesc);
            p->value["status"] = tars::JsonOutput::writeJson(status);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(spuId,pObj->value["spuId"], true);
            tars::JsonInput::readJson(name,pObj->value["name"], true);
            tars::JsonInput::readJson(brandName,pObj->value["brandName"], true);
            tars::JsonInput::readJson(maker,pObj->value["maker"], true);
            tars::JsonInput::readJson(sDesc,pObj->value["sDesc"], true);
            tars::JsonInput::readJson(status,pObj->value["status"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(spuId,"spuId");
            _ds.display(name,"name");
            _ds.display(brandName,"brandName");
            _ds.display(maker,"maker");
            _ds.display(sDesc,"sDesc");
            _ds.display(status,"status");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(spuId, true);
            _ds.displaySimple(name, true);
            _ds.displaySimple(brandName, true);
            _ds.displaySimple(maker, true);
            _ds.displaySimple(sDesc, true);
            _ds.displaySimple(status, false);
            return _os;
        }
    public:
        tars::Int32 spuId;
        std::string name;
        std::string brandName;
        std::string maker;
        std::string sDesc;
        tars::Int32 status;
    };
    inline bool operator==(const GoodsSPUSimpleInfo&l, const GoodsSPUSimpleInfo&r)
    {
        return l.spuId == r.spuId && l.name == r.name && l.brandName == r.brandName && l.maker == r.maker && l.sDesc == r.sDesc && l.status == r.status;
    }
    inline bool operator!=(const GoodsSPUSimpleInfo&l, const GoodsSPUSimpleInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GoodsSPUSimpleInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GoodsSPUSimpleInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GoodsSPUDetail : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GoodsSPUDetail";
        }
        static string MD5()
        {
            return "0b7f624e362c7798f0fbc0a2e492e1bc";
        }
        GoodsSPUDetail()
        :spuId(0),name(""),brandName(""),makerId(0),sDesc(""),status(-1),brandId(0),desc(""),makerName(""),model("")
        {
        }
        void resetDefautlt()
        {
            spuId = 0;
            name = "";
            brandName = "";
            makerId = 0;
            sDesc = "";
            status = -1;
            brandId = 0;
            desc = "";
            makerName = "";
            model = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(spuId, 0);
            _os.write(name, 1);
            _os.write(brandName, 2);
            _os.write(makerId, 3);
            _os.write(sDesc, 4);
            _os.write(status, 5);
            _os.write(brandId, 6);
            _os.write(desc, 7);
            _os.write(makerName, 8);
            _os.write(model, 9);
            _os.write(mediaInfo, 10);
            _os.write(categoryInfo, 11);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(spuId, 0, true);
            _is.read(name, 1, true);
            _is.read(brandName, 2, true);
            _is.read(makerId, 3, true);
            _is.read(sDesc, 4, true);
            _is.read(status, 5, true);
            _is.read(brandId, 6, true);
            _is.read(desc, 7, true);
            _is.read(makerName, 8, true);
            _is.read(model, 9, true);
            _is.read(mediaInfo, 10, true);
            _is.read(categoryInfo, 11, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["spuId"] = tars::JsonOutput::writeJson(spuId);
            p->value["name"] = tars::JsonOutput::writeJson(name);
            p->value["brandName"] = tars::JsonOutput::writeJson(brandName);
            p->value["makerId"] = tars::JsonOutput::writeJson(makerId);
            p->value["sDesc"] = tars::JsonOutput::writeJson(sDesc);
            p->value["status"] = tars::JsonOutput::writeJson(status);
            p->value["brandId"] = tars::JsonOutput::writeJson(brandId);
            p->value["desc"] = tars::JsonOutput::writeJson(desc);
            p->value["makerName"] = tars::JsonOutput::writeJson(makerName);
            p->value["model"] = tars::JsonOutput::writeJson(model);
            p->value["mediaInfo"] = tars::JsonOutput::writeJson(mediaInfo);
            p->value["categoryInfo"] = tars::JsonOutput::writeJson(categoryInfo);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(spuId,pObj->value["spuId"], true);
            tars::JsonInput::readJson(name,pObj->value["name"], true);
            tars::JsonInput::readJson(brandName,pObj->value["brandName"], true);
            tars::JsonInput::readJson(makerId,pObj->value["makerId"], true);
            tars::JsonInput::readJson(sDesc,pObj->value["sDesc"], true);
            tars::JsonInput::readJson(status,pObj->value["status"], true);
            tars::JsonInput::readJson(brandId,pObj->value["brandId"], true);
            tars::JsonInput::readJson(desc,pObj->value["desc"], true);
            tars::JsonInput::readJson(makerName,pObj->value["makerName"], true);
            tars::JsonInput::readJson(model,pObj->value["model"], true);
            tars::JsonInput::readJson(mediaInfo,pObj->value["mediaInfo"], true);
            tars::JsonInput::readJson(categoryInfo,pObj->value["categoryInfo"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(spuId,"spuId");
            _ds.display(name,"name");
            _ds.display(brandName,"brandName");
            _ds.display(makerId,"makerId");
            _ds.display(sDesc,"sDesc");
            _ds.display(status,"status");
            _ds.display(brandId,"brandId");
            _ds.display(desc,"desc");
            _ds.display(makerName,"makerName");
            _ds.display(model,"model");
            _ds.display(mediaInfo,"mediaInfo");
            _ds.display(categoryInfo,"categoryInfo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(spuId, true);
            _ds.displaySimple(name, true);
            _ds.displaySimple(brandName, true);
            _ds.displaySimple(makerId, true);
            _ds.displaySimple(sDesc, true);
            _ds.displaySimple(status, true);
            _ds.displaySimple(brandId, true);
            _ds.displaySimple(desc, true);
            _ds.displaySimple(makerName, true);
            _ds.displaySimple(model, true);
            _ds.displaySimple(mediaInfo, true);
            _ds.displaySimple(categoryInfo, false);
            return _os;
        }
    public:
        tars::Int32 spuId;
        std::string name;
        std::string brandName;
        tars::Int32 makerId;
        std::string sDesc;
        tars::Int32 status;
        tars::Int32 brandId;
        std::string desc;
        std::string makerName;
        std::string model;
        vector<HardwareApplet::GoodsMediaInfo> mediaInfo;
        vector<HardwareApplet::CategoryItem> categoryInfo;
    };
    inline bool operator==(const GoodsSPUDetail&l, const GoodsSPUDetail&r)
    {
        return l.spuId == r.spuId && l.name == r.name && l.brandName == r.brandName && l.makerId == r.makerId && l.sDesc == r.sDesc && l.status == r.status && l.brandId == r.brandId && l.desc == r.desc && l.makerName == r.makerName && l.model == r.model && l.mediaInfo == r.mediaInfo && l.categoryInfo == r.categoryInfo;
    }
    inline bool operator!=(const GoodsSPUDetail&l, const GoodsSPUDetail&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GoodsSPUDetail&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GoodsSPUDetail&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetGoodsSPUListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetGoodsSPUListReq";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        GetGoodsSPUListReq()
        :name("")
        {
        }
        void resetDefautlt()
        {
            name = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(name, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(name, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["name"] = tars::JsonOutput::writeJson(name);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(name,pObj->value["name"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(name,"name");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(name, false);
            return _os;
        }
    public:
        std::string name;
    };
    inline bool operator==(const GetGoodsSPUListReq&l, const GetGoodsSPUListReq&r)
    {
        return l.name == r.name;
    }
    inline bool operator!=(const GetGoodsSPUListReq&l, const GetGoodsSPUListReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetGoodsSPUListReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetGoodsSPUListReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetGoodsSPUListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetGoodsSPUListRsp";
        }
        static string MD5()
        {
            return "2cce45404fc2fd9f561860cc76e15d66";
        }
        GetGoodsSPUListRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
            _os.write(infoList, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
            _is.read(infoList, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            p->value["infoList"] = tars::JsonOutput::writeJson(infoList);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
            tars::JsonInput::readJson(infoList,pObj->value["infoList"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            _ds.display(infoList,"infoList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(infoList, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
        vector<HardwareApplet::GoodsSPUSimpleInfo> infoList;
    };
    inline bool operator==(const GetGoodsSPUListRsp&l, const GetGoodsSPUListRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg && l.infoList == r.infoList;
    }
    inline bool operator!=(const GetGoodsSPUListRsp&l, const GetGoodsSPUListRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetGoodsSPUListRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetGoodsSPUListRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetGoodsSPUListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetGoodsSPUListReq";
        }
        static string MD5()
        {
            return "90c56ca34ef399dceb3b4ed824aa883e";
        }
        ProxyGetGoodsSPUListReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::GetGoodsSPUListReq body;
    };
    inline bool operator==(const ProxyGetGoodsSPUListReq&l, const ProxyGetGoodsSPUListReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetGoodsSPUListReq&l, const ProxyGetGoodsSPUListReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetGoodsSPUListReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetGoodsSPUListReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetGoodsSPUListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetGoodsSPUListRsp";
        }
        static string MD5()
        {
            return "2ce1169a08fb5caa9f21da474c5240ce";
        }
        ProxyGetGoodsSPUListRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::GetGoodsSPUListRsp body;
    };
    inline bool operator==(const ProxyGetGoodsSPUListRsp&l, const ProxyGetGoodsSPUListRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetGoodsSPUListRsp&l, const ProxyGetGoodsSPUListRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetGoodsSPUListRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetGoodsSPUListRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AddGoodsSPUInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AddGoodsSPUInfoReq";
        }
        static string MD5()
        {
            return "f95c0c4ca7733e67f9478780c0c66d58";
        }
        AddGoodsSPUInfoReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(detail, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(detail, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["detail"] = tars::JsonOutput::writeJson(detail);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(detail,pObj->value["detail"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(detail,"detail");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(detail, false);
            return _os;
        }
    public:
        HardwareApplet::GoodsSPUDetail detail;
    };
    inline bool operator==(const AddGoodsSPUInfoReq&l, const AddGoodsSPUInfoReq&r)
    {
        return l.detail == r.detail;
    }
    inline bool operator!=(const AddGoodsSPUInfoReq&l, const AddGoodsSPUInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AddGoodsSPUInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AddGoodsSPUInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AddGoodsSPUInfoRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AddGoodsSPUInfoRsp";
        }
        static string MD5()
        {
            return "b84e4dd5dd1d7c43dbe702512024405f";
        }
        AddGoodsSPUInfoRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
    };
    inline bool operator==(const AddGoodsSPUInfoRsp&l, const AddGoodsSPUInfoRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg;
    }
    inline bool operator!=(const AddGoodsSPUInfoRsp&l, const AddGoodsSPUInfoRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AddGoodsSPUInfoRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AddGoodsSPUInfoRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyAddGoodsSPUInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyAddGoodsSPUInfoReq";
        }
        static string MD5()
        {
            return "5660b975c349c8eb736f73a048183b44";
        }
        ProxyAddGoodsSPUInfoReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::AddGoodsSPUInfoReq body;
    };
    inline bool operator==(const ProxyAddGoodsSPUInfoReq&l, const ProxyAddGoodsSPUInfoReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyAddGoodsSPUInfoReq&l, const ProxyAddGoodsSPUInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyAddGoodsSPUInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyAddGoodsSPUInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyAddGoodsSPUInfoRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyAddGoodsSPUInfoRsp";
        }
        static string MD5()
        {
            return "87f267ce6ec47f8a135c444509c32770";
        }
        ProxyAddGoodsSPUInfoRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::AddGoodsSPUInfoRsp body;
    };
    inline bool operator==(const ProxyAddGoodsSPUInfoRsp&l, const ProxyAddGoodsSPUInfoRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyAddGoodsSPUInfoRsp&l, const ProxyAddGoodsSPUInfoRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyAddGoodsSPUInfoRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyAddGoodsSPUInfoRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GoodsSKUAttrInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GoodsSKUAttrInfo";
        }
        static string MD5()
        {
            return "50b5f1eaeb5ef9a625c9d9990451b1db";
        }
        GoodsSKUAttrInfo()
        :attrId(0),attrName(""),attrValueId(0),attrValueName("")
        {
        }
        void resetDefautlt()
        {
            attrId = 0;
            attrName = "";
            attrValueId = 0;
            attrValueName = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(attrId, 0);
            _os.write(attrName, 1);
            _os.write(attrValueId, 2);
            _os.write(attrValueName, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(attrId, 0, true);
            _is.read(attrName, 1, true);
            _is.read(attrValueId, 2, true);
            _is.read(attrValueName, 3, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["attrId"] = tars::JsonOutput::writeJson(attrId);
            p->value["attrName"] = tars::JsonOutput::writeJson(attrName);
            p->value["attrValueId"] = tars::JsonOutput::writeJson(attrValueId);
            p->value["attrValueName"] = tars::JsonOutput::writeJson(attrValueName);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(attrId,pObj->value["attrId"], true);
            tars::JsonInput::readJson(attrName,pObj->value["attrName"], true);
            tars::JsonInput::readJson(attrValueId,pObj->value["attrValueId"], true);
            tars::JsonInput::readJson(attrValueName,pObj->value["attrValueName"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(attrId,"attrId");
            _ds.display(attrName,"attrName");
            _ds.display(attrValueId,"attrValueId");
            _ds.display(attrValueName,"attrValueName");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(attrId, true);
            _ds.displaySimple(attrName, true);
            _ds.displaySimple(attrValueId, true);
            _ds.displaySimple(attrValueName, false);
            return _os;
        }
    public:
        tars::Int32 attrId;
        std::string attrName;
        tars::Int32 attrValueId;
        std::string attrValueName;
    };
    inline bool operator==(const GoodsSKUAttrInfo&l, const GoodsSKUAttrInfo&r)
    {
        return l.attrId == r.attrId && l.attrName == r.attrName && l.attrValueId == r.attrValueId && l.attrValueName == r.attrValueName;
    }
    inline bool operator!=(const GoodsSKUAttrInfo&l, const GoodsSKUAttrInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GoodsSKUAttrInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GoodsSKUAttrInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct SKUStockItem : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.SKUStockItem";
        }
        static string MD5()
        {
            return "291ac63daaaf4c880e2ed8f78707927d";
        }
        SKUStockItem()
        :id(0),stock(0),warningStock(0),skuId(0),warehouseId(0),warehouseName("")
        {
        }
        void resetDefautlt()
        {
            id = 0;
            stock = 0;
            warningStock = 0;
            skuId = 0;
            warehouseId = 0;
            warehouseName = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(id, 0);
            _os.write(stock, 1);
            _os.write(warningStock, 2);
            _os.write(skuId, 3);
            _os.write(warehouseId, 4);
            _os.write(warehouseName, 5);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(id, 0, true);
            _is.read(stock, 1, true);
            _is.read(warningStock, 2, true);
            _is.read(skuId, 3, true);
            _is.read(warehouseId, 4, true);
            _is.read(warehouseName, 5, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["id"] = tars::JsonOutput::writeJson(id);
            p->value["stock"] = tars::JsonOutput::writeJson(stock);
            p->value["warningStock"] = tars::JsonOutput::writeJson(warningStock);
            p->value["skuId"] = tars::JsonOutput::writeJson(skuId);
            p->value["warehouseId"] = tars::JsonOutput::writeJson(warehouseId);
            p->value["warehouseName"] = tars::JsonOutput::writeJson(warehouseName);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(id,pObj->value["id"], true);
            tars::JsonInput::readJson(stock,pObj->value["stock"], true);
            tars::JsonInput::readJson(warningStock,pObj->value["warningStock"], true);
            tars::JsonInput::readJson(skuId,pObj->value["skuId"], true);
            tars::JsonInput::readJson(warehouseId,pObj->value["warehouseId"], true);
            tars::JsonInput::readJson(warehouseName,pObj->value["warehouseName"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(id,"id");
            _ds.display(stock,"stock");
            _ds.display(warningStock,"warningStock");
            _ds.display(skuId,"skuId");
            _ds.display(warehouseId,"warehouseId");
            _ds.display(warehouseName,"warehouseName");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(id, true);
            _ds.displaySimple(stock, true);
            _ds.displaySimple(warningStock, true);
            _ds.displaySimple(skuId, true);
            _ds.displaySimple(warehouseId, true);
            _ds.displaySimple(warehouseName, false);
            return _os;
        }
    public:
        tars::Int32 id;
        tars::Int32 stock;
        tars::Int32 warningStock;
        tars::Int32 skuId;
        tars::Int32 warehouseId;
        std::string warehouseName;
    };
    inline bool operator==(const SKUStockItem&l, const SKUStockItem&r)
    {
        return l.id == r.id && l.stock == r.stock && l.warningStock == r.warningStock && l.skuId == r.skuId && l.warehouseId == r.warehouseId && l.warehouseName == r.warehouseName;
    }
    inline bool operator!=(const SKUStockItem&l, const SKUStockItem&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const SKUStockItem&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,SKUStockItem&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GoodsSKUInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GoodsSKUInfo";
        }
        static string MD5()
        {
            return "6ecdb3aa8aea822f3d93237aea93005b";
        }
        GoodsSKUInfo()
        :skuId(0),spuId(0),name(""),stock(0),warnStock(0),price(0),minCount(0),isDefault(0),imgUrl("")
        {
        }
        void resetDefautlt()
        {
            skuId = 0;
            spuId = 0;
            name = "";
            stock = 0;
            warnStock = 0;
            price = 0;
            minCount = 0;
            isDefault = 0;
            imgUrl = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(skuId, 0);
            _os.write(spuId, 1);
            _os.write(name, 2);
            _os.write(stock, 3);
            _os.write(warnStock, 4);
            _os.write(price, 5);
            _os.write(minCount, 6);
            _os.write(isDefault, 7);
            _os.write(imgUrl, 8);
            _os.write(stockList, 9);
            _os.write(attrList, 10);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(skuId, 0, true);
            _is.read(spuId, 1, true);
            _is.read(name, 2, true);
            _is.read(stock, 3, true);
            _is.read(warnStock, 4, true);
            _is.read(price, 5, true);
            _is.read(minCount, 6, true);
            _is.read(isDefault, 7, true);
            _is.read(imgUrl, 8, true);
            _is.read(stockList, 9, true);
            _is.read(attrList, 10, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["skuId"] = tars::JsonOutput::writeJson(skuId);
            p->value["spuId"] = tars::JsonOutput::writeJson(spuId);
            p->value["name"] = tars::JsonOutput::writeJson(name);
            p->value["stock"] = tars::JsonOutput::writeJson(stock);
            p->value["warnStock"] = tars::JsonOutput::writeJson(warnStock);
            p->value["price"] = tars::JsonOutput::writeJson(price);
            p->value["minCount"] = tars::JsonOutput::writeJson(minCount);
            p->value["isDefault"] = tars::JsonOutput::writeJson(isDefault);
            p->value["imgUrl"] = tars::JsonOutput::writeJson(imgUrl);
            p->value["stockList"] = tars::JsonOutput::writeJson(stockList);
            p->value["attrList"] = tars::JsonOutput::writeJson(attrList);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(skuId,pObj->value["skuId"], true);
            tars::JsonInput::readJson(spuId,pObj->value["spuId"], true);
            tars::JsonInput::readJson(name,pObj->value["name"], true);
            tars::JsonInput::readJson(stock,pObj->value["stock"], true);
            tars::JsonInput::readJson(warnStock,pObj->value["warnStock"], true);
            tars::JsonInput::readJson(price,pObj->value["price"], true);
            tars::JsonInput::readJson(minCount,pObj->value["minCount"], true);
            tars::JsonInput::readJson(isDefault,pObj->value["isDefault"], true);
            tars::JsonInput::readJson(imgUrl,pObj->value["imgUrl"], true);
            tars::JsonInput::readJson(stockList,pObj->value["stockList"], true);
            tars::JsonInput::readJson(attrList,pObj->value["attrList"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(skuId,"skuId");
            _ds.display(spuId,"spuId");
            _ds.display(name,"name");
            _ds.display(stock,"stock");
            _ds.display(warnStock,"warnStock");
            _ds.display(price,"price");
            _ds.display(minCount,"minCount");
            _ds.display(isDefault,"isDefault");
            _ds.display(imgUrl,"imgUrl");
            _ds.display(stockList,"stockList");
            _ds.display(attrList,"attrList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(skuId, true);
            _ds.displaySimple(spuId, true);
            _ds.displaySimple(name, true);
            _ds.displaySimple(stock, true);
            _ds.displaySimple(warnStock, true);
            _ds.displaySimple(price, true);
            _ds.displaySimple(minCount, true);
            _ds.displaySimple(isDefault, true);
            _ds.displaySimple(imgUrl, true);
            _ds.displaySimple(stockList, true);
            _ds.displaySimple(attrList, false);
            return _os;
        }
    public:
        tars::Int32 skuId;
        tars::Int32 spuId;
        std::string name;
        tars::Int32 stock;
        tars::Int32 warnStock;
        tars::Int32 price;
        tars::Int32 minCount;
        tars::Int32 isDefault;
        std::string imgUrl;
        vector<HardwareApplet::SKUStockItem> stockList;
        vector<HardwareApplet::GoodsSKUAttrInfo> attrList;
    };
    inline bool operator==(const GoodsSKUInfo&l, const GoodsSKUInfo&r)
    {
        return l.skuId == r.skuId && l.spuId == r.spuId && l.name == r.name && l.stock == r.stock && l.warnStock == r.warnStock && l.price == r.price && l.minCount == r.minCount && l.isDefault == r.isDefault && l.imgUrl == r.imgUrl && l.stockList == r.stockList && l.attrList == r.attrList;
    }
    inline bool operator!=(const GoodsSKUInfo&l, const GoodsSKUInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GoodsSKUInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GoodsSKUInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AddGoodsSKUInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AddGoodsSKUInfoReq";
        }
        static string MD5()
        {
            return "de21aa7752e2123729bdc02fe936a3d6";
        }
        AddGoodsSKUInfoReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(skuInfo, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(skuInfo, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["skuInfo"] = tars::JsonOutput::writeJson(skuInfo);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(skuInfo,pObj->value["skuInfo"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(skuInfo,"skuInfo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(skuInfo, false);
            return _os;
        }
    public:
        HardwareApplet::GoodsSKUInfo skuInfo;
    };
    inline bool operator==(const AddGoodsSKUInfoReq&l, const AddGoodsSKUInfoReq&r)
    {
        return l.skuInfo == r.skuInfo;
    }
    inline bool operator!=(const AddGoodsSKUInfoReq&l, const AddGoodsSKUInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AddGoodsSKUInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AddGoodsSKUInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AddGoodsSKUInfoRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AddGoodsSKUInfoRsp";
        }
        static string MD5()
        {
            return "b84e4dd5dd1d7c43dbe702512024405f";
        }
        AddGoodsSKUInfoRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
    };
    inline bool operator==(const AddGoodsSKUInfoRsp&l, const AddGoodsSKUInfoRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg;
    }
    inline bool operator!=(const AddGoodsSKUInfoRsp&l, const AddGoodsSKUInfoRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AddGoodsSKUInfoRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AddGoodsSKUInfoRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyAddGoodsSKUInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyAddGoodsSKUInfoReq";
        }
        static string MD5()
        {
            return "13091fe306a2ab13f2a8244f5c6256bc";
        }
        ProxyAddGoodsSKUInfoReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::AddGoodsSKUInfoReq body;
    };
    inline bool operator==(const ProxyAddGoodsSKUInfoReq&l, const ProxyAddGoodsSKUInfoReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyAddGoodsSKUInfoReq&l, const ProxyAddGoodsSKUInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyAddGoodsSKUInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyAddGoodsSKUInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyAddGoodsSKUInfoRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyAddGoodsSKUInfoRsp";
        }
        static string MD5()
        {
            return "7a25df925976a84809eac784ee1138cf";
        }
        ProxyAddGoodsSKUInfoRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::AddGoodsSKUInfoRsp body;
    };
    inline bool operator==(const ProxyAddGoodsSKUInfoRsp&l, const ProxyAddGoodsSKUInfoRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyAddGoodsSKUInfoRsp&l, const ProxyAddGoodsSKUInfoRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyAddGoodsSKUInfoRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyAddGoodsSKUInfoRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetGoodsSKUListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetGoodsSKUListReq";
        }
        static string MD5()
        {
            return "4eb3d078d60bfcdcc0f3c102edc08c24";
        }
        GetGoodsSKUListReq()
        :spuId(0)
        {
        }
        void resetDefautlt()
        {
            spuId = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(spuId, 0);
            _os.write(attrList, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(spuId, 0, true);
            _is.read(attrList, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["spuId"] = tars::JsonOutput::writeJson(spuId);
            p->value["attrList"] = tars::JsonOutput::writeJson(attrList);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(spuId,pObj->value["spuId"], true);
            tars::JsonInput::readJson(attrList,pObj->value["attrList"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(spuId,"spuId");
            _ds.display(attrList,"attrList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(spuId, true);
            _ds.displaySimple(attrList, false);
            return _os;
        }
    public:
        tars::Int32 spuId;
        vector<HardwareApplet::GoodsSKUAttrInfo> attrList;
    };
    inline bool operator==(const GetGoodsSKUListReq&l, const GetGoodsSKUListReq&r)
    {
        return l.spuId == r.spuId && l.attrList == r.attrList;
    }
    inline bool operator!=(const GetGoodsSKUListReq&l, const GetGoodsSKUListReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetGoodsSKUListReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetGoodsSKUListReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetGoodsSKUListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetGoodsSKUListRsp";
        }
        static string MD5()
        {
            return "967e530395b872d5ea86765e38c0dd28";
        }
        GetGoodsSKUListRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
            _os.write(infoList, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
            _is.read(infoList, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            p->value["infoList"] = tars::JsonOutput::writeJson(infoList);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
            tars::JsonInput::readJson(infoList,pObj->value["infoList"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            _ds.display(infoList,"infoList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(infoList, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
        vector<HardwareApplet::GoodsSKUInfo> infoList;
    };
    inline bool operator==(const GetGoodsSKUListRsp&l, const GetGoodsSKUListRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg && l.infoList == r.infoList;
    }
    inline bool operator!=(const GetGoodsSKUListRsp&l, const GetGoodsSKUListRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetGoodsSKUListRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetGoodsSKUListRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetGoodsSKUListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetGoodsSKUListReq";
        }
        static string MD5()
        {
            return "a1ff29a39844dacb1a315a5a800b7eda";
        }
        ProxyGetGoodsSKUListReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::GetGoodsSKUListReq body;
    };
    inline bool operator==(const ProxyGetGoodsSKUListReq&l, const ProxyGetGoodsSKUListReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetGoodsSKUListReq&l, const ProxyGetGoodsSKUListReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetGoodsSKUListReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetGoodsSKUListReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetGoodsSKUListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetGoodsSKUListRsp";
        }
        static string MD5()
        {
            return "d69569828d60a0575d1d6c8e278e73ac";
        }
        ProxyGetGoodsSKUListRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::GetGoodsSKUListRsp body;
    };
    inline bool operator==(const ProxyGetGoodsSKUListRsp&l, const ProxyGetGoodsSKUListRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetGoodsSKUListRsp&l, const ProxyGetGoodsSKUListRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetGoodsSKUListRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetGoodsSKUListRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TransferGoodsStockReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.TransferGoodsStockReq";
        }
        static string MD5()
        {
            return "d454490a918484bf9146bb56071aacaf";
        }
        TransferGoodsStockReq()
        :skuId(0),oldWarehouseId(0),newWarehouseId(0),num(0)
        {
        }
        void resetDefautlt()
        {
            skuId = 0;
            oldWarehouseId = 0;
            newWarehouseId = 0;
            num = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(skuId, 0);
            _os.write(oldWarehouseId, 1);
            _os.write(newWarehouseId, 2);
            _os.write(num, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(skuId, 0, true);
            _is.read(oldWarehouseId, 1, true);
            _is.read(newWarehouseId, 2, true);
            _is.read(num, 3, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["skuId"] = tars::JsonOutput::writeJson(skuId);
            p->value["oldWarehouseId"] = tars::JsonOutput::writeJson(oldWarehouseId);
            p->value["newWarehouseId"] = tars::JsonOutput::writeJson(newWarehouseId);
            p->value["num"] = tars::JsonOutput::writeJson(num);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(skuId,pObj->value["skuId"], true);
            tars::JsonInput::readJson(oldWarehouseId,pObj->value["oldWarehouseId"], true);
            tars::JsonInput::readJson(newWarehouseId,pObj->value["newWarehouseId"], true);
            tars::JsonInput::readJson(num,pObj->value["num"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(skuId,"skuId");
            _ds.display(oldWarehouseId,"oldWarehouseId");
            _ds.display(newWarehouseId,"newWarehouseId");
            _ds.display(num,"num");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(skuId, true);
            _ds.displaySimple(oldWarehouseId, true);
            _ds.displaySimple(newWarehouseId, true);
            _ds.displaySimple(num, false);
            return _os;
        }
    public:
        tars::Int32 skuId;
        tars::Int32 oldWarehouseId;
        tars::Int32 newWarehouseId;
        tars::Int32 num;
    };
    inline bool operator==(const TransferGoodsStockReq&l, const TransferGoodsStockReq&r)
    {
        return l.skuId == r.skuId && l.oldWarehouseId == r.oldWarehouseId && l.newWarehouseId == r.newWarehouseId && l.num == r.num;
    }
    inline bool operator!=(const TransferGoodsStockReq&l, const TransferGoodsStockReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TransferGoodsStockReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TransferGoodsStockReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TransferGoodsStockRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.TransferGoodsStockRsp";
        }
        static string MD5()
        {
            return "b84e4dd5dd1d7c43dbe702512024405f";
        }
        TransferGoodsStockRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
    };
    inline bool operator==(const TransferGoodsStockRsp&l, const TransferGoodsStockRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg;
    }
    inline bool operator!=(const TransferGoodsStockRsp&l, const TransferGoodsStockRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TransferGoodsStockRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TransferGoodsStockRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyTransferGoodsStockReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyTransferGoodsStockReq";
        }
        static string MD5()
        {
            return "7c76708d696493142da03340199b5078";
        }
        ProxyTransferGoodsStockReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::TransferGoodsStockReq body;
    };
    inline bool operator==(const ProxyTransferGoodsStockReq&l, const ProxyTransferGoodsStockReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyTransferGoodsStockReq&l, const ProxyTransferGoodsStockReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyTransferGoodsStockReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyTransferGoodsStockReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyTransferGoodsStockRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyTransferGoodsStockRsp";
        }
        static string MD5()
        {
            return "984f81cea0b9720db2453303d8accdfa";
        }
        ProxyTransferGoodsStockRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::TransferGoodsStockRsp body;
    };
    inline bool operator==(const ProxyTransferGoodsStockRsp&l, const ProxyTransferGoodsStockRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyTransferGoodsStockRsp&l, const ProxyTransferGoodsStockRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyTransferGoodsStockRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyTransferGoodsStockRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AddressInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AddressInfo";
        }
        static string MD5()
        {
            return "b4a4e8c10828d32960721331da0377da";
        }
        AddressInfo()
        :addressId(0),uid(0),phoneNum(""),province(""),city(""),county(""),addressDetail(""),receiver("")
        {
        }
        void resetDefautlt()
        {
            addressId = 0;
            uid = 0;
            phoneNum = "";
            province = "";
            city = "";
            county = "";
            addressDetail = "";
            receiver = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(addressId, 0);
            _os.write(uid, 1);
            _os.write(phoneNum, 2);
            _os.write(province, 3);
            _os.write(city, 4);
            _os.write(county, 5);
            _os.write(addressDetail, 6);
            _os.write(receiver, 7);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(addressId, 0, true);
            _is.read(uid, 1, true);
            _is.read(phoneNum, 2, true);
            _is.read(province, 3, true);
            _is.read(city, 4, true);
            _is.read(county, 5, true);
            _is.read(addressDetail, 6, true);
            _is.read(receiver, 7, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["addressId"] = tars::JsonOutput::writeJson(addressId);
            p->value["uid"] = tars::JsonOutput::writeJson(uid);
            p->value["phoneNum"] = tars::JsonOutput::writeJson(phoneNum);
            p->value["province"] = tars::JsonOutput::writeJson(province);
            p->value["city"] = tars::JsonOutput::writeJson(city);
            p->value["county"] = tars::JsonOutput::writeJson(county);
            p->value["addressDetail"] = tars::JsonOutput::writeJson(addressDetail);
            p->value["receiver"] = tars::JsonOutput::writeJson(receiver);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(addressId,pObj->value["addressId"], true);
            tars::JsonInput::readJson(uid,pObj->value["uid"], true);
            tars::JsonInput::readJson(phoneNum,pObj->value["phoneNum"], true);
            tars::JsonInput::readJson(province,pObj->value["province"], true);
            tars::JsonInput::readJson(city,pObj->value["city"], true);
            tars::JsonInput::readJson(county,pObj->value["county"], true);
            tars::JsonInput::readJson(addressDetail,pObj->value["addressDetail"], true);
            tars::JsonInput::readJson(receiver,pObj->value["receiver"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(addressId,"addressId");
            _ds.display(uid,"uid");
            _ds.display(phoneNum,"phoneNum");
            _ds.display(province,"province");
            _ds.display(city,"city");
            _ds.display(county,"county");
            _ds.display(addressDetail,"addressDetail");
            _ds.display(receiver,"receiver");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(addressId, true);
            _ds.displaySimple(uid, true);
            _ds.displaySimple(phoneNum, true);
            _ds.displaySimple(province, true);
            _ds.displaySimple(city, true);
            _ds.displaySimple(county, true);
            _ds.displaySimple(addressDetail, true);
            _ds.displaySimple(receiver, false);
            return _os;
        }
    public:
        tars::Int32 addressId;
        tars::Int32 uid;
        std::string phoneNum;
        std::string province;
        std::string city;
        std::string county;
        std::string addressDetail;
        std::string receiver;
    };
    inline bool operator==(const AddressInfo&l, const AddressInfo&r)
    {
        return l.addressId == r.addressId && l.uid == r.uid && l.phoneNum == r.phoneNum && l.province == r.province && l.city == r.city && l.county == r.county && l.addressDetail == r.addressDetail && l.receiver == r.receiver;
    }
    inline bool operator!=(const AddressInfo&l, const AddressInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AddressInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AddressInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AddMyAddressInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AddMyAddressInfoReq";
        }
        static string MD5()
        {
            return "83f9c427d37bc0bf672679f0235e5c14";
        }
        AddMyAddressInfoReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(addressInfo, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(addressInfo, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["addressInfo"] = tars::JsonOutput::writeJson(addressInfo);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(addressInfo,pObj->value["addressInfo"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(addressInfo,"addressInfo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(addressInfo, false);
            return _os;
        }
    public:
        HardwareApplet::AddressInfo addressInfo;
    };
    inline bool operator==(const AddMyAddressInfoReq&l, const AddMyAddressInfoReq&r)
    {
        return l.addressInfo == r.addressInfo;
    }
    inline bool operator!=(const AddMyAddressInfoReq&l, const AddMyAddressInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AddMyAddressInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AddMyAddressInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AddMyAddressInfoRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AddMyAddressInfoRsp";
        }
        static string MD5()
        {
            return "b84e4dd5dd1d7c43dbe702512024405f";
        }
        AddMyAddressInfoRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
    };
    inline bool operator==(const AddMyAddressInfoRsp&l, const AddMyAddressInfoRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg;
    }
    inline bool operator!=(const AddMyAddressInfoRsp&l, const AddMyAddressInfoRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AddMyAddressInfoRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AddMyAddressInfoRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyAddMyAddressInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyAddMyAddressInfoReq";
        }
        static string MD5()
        {
            return "d244c64304f004794ae91101af43d1ae";
        }
        ProxyAddMyAddressInfoReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::AddMyAddressInfoReq body;
    };
    inline bool operator==(const ProxyAddMyAddressInfoReq&l, const ProxyAddMyAddressInfoReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyAddMyAddressInfoReq&l, const ProxyAddMyAddressInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyAddMyAddressInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyAddMyAddressInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyAddMyAddressInfoRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyAddMyAddressInfoRsp";
        }
        static string MD5()
        {
            return "3ce67f5dbab46b7c5e7f135b41a63a56";
        }
        ProxyAddMyAddressInfoRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::AddMyAddressInfoRsp body;
    };
    inline bool operator==(const ProxyAddMyAddressInfoRsp&l, const ProxyAddMyAddressInfoRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyAddMyAddressInfoRsp&l, const ProxyAddMyAddressInfoRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyAddMyAddressInfoRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyAddMyAddressInfoRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetMyAddressListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetMyAddressListReq";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        GetMyAddressListReq()
        :reserved_field("")
        {
        }
        void resetDefautlt()
        {
            reserved_field = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (reserved_field != "")
            {
                _os.write(reserved_field, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(reserved_field, 0, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["reserved_field"] = tars::JsonOutput::writeJson(reserved_field);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(reserved_field,pObj->value["reserved_field"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(reserved_field,"reserved_field");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(reserved_field, false);
            return _os;
        }
    public:
        std::string reserved_field;
    };
    inline bool operator==(const GetMyAddressListReq&l, const GetMyAddressListReq&r)
    {
        return l.reserved_field == r.reserved_field;
    }
    inline bool operator!=(const GetMyAddressListReq&l, const GetMyAddressListReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetMyAddressListReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetMyAddressListReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetMyAddressListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetMyAddressListRsp";
        }
        static string MD5()
        {
            return "e1f0475c754a356ce221ce7aeb7e7772";
        }
        GetMyAddressListRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
            _os.write(infoList, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
            _is.read(infoList, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            p->value["infoList"] = tars::JsonOutput::writeJson(infoList);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
            tars::JsonInput::readJson(infoList,pObj->value["infoList"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            _ds.display(infoList,"infoList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(infoList, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
        vector<HardwareApplet::AddressInfo> infoList;
    };
    inline bool operator==(const GetMyAddressListRsp&l, const GetMyAddressListRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg && l.infoList == r.infoList;
    }
    inline bool operator!=(const GetMyAddressListRsp&l, const GetMyAddressListRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetMyAddressListRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetMyAddressListRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetMyAddressListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetMyAddressListReq";
        }
        static string MD5()
        {
            return "8e3ed5f32d77e37735cf72750692968c";
        }
        ProxyGetMyAddressListReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::GetMyAddressListReq body;
    };
    inline bool operator==(const ProxyGetMyAddressListReq&l, const ProxyGetMyAddressListReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetMyAddressListReq&l, const ProxyGetMyAddressListReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetMyAddressListReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetMyAddressListReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetMyAddressListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetMyAddressListRsp";
        }
        static string MD5()
        {
            return "6f5aa736f710c2435f887a44d485c77a";
        }
        ProxyGetMyAddressListRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::GetMyAddressListRsp body;
    };
    inline bool operator==(const ProxyGetMyAddressListRsp&l, const ProxyGetMyAddressListRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetMyAddressListRsp&l, const ProxyGetMyAddressListRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetMyAddressListRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetMyAddressListRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetProvinceListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetProvinceListReq";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        GetProvinceListReq()
        :reserved_field("")
        {
        }
        void resetDefautlt()
        {
            reserved_field = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (reserved_field != "")
            {
                _os.write(reserved_field, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(reserved_field, 0, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["reserved_field"] = tars::JsonOutput::writeJson(reserved_field);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(reserved_field,pObj->value["reserved_field"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(reserved_field,"reserved_field");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(reserved_field, false);
            return _os;
        }
    public:
        std::string reserved_field;
    };
    inline bool operator==(const GetProvinceListReq&l, const GetProvinceListReq&r)
    {
        return l.reserved_field == r.reserved_field;
    }
    inline bool operator!=(const GetProvinceListReq&l, const GetProvinceListReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetProvinceListReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetProvinceListReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetProvinceListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetProvinceListRsp";
        }
        static string MD5()
        {
            return "207870fa3e5340da2042f951415ac96b";
        }
        GetProvinceListRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
            _os.write(nameList, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
            _is.read(nameList, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            p->value["nameList"] = tars::JsonOutput::writeJson(nameList);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
            tars::JsonInput::readJson(nameList,pObj->value["nameList"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            _ds.display(nameList,"nameList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(nameList, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
        vector<std::string> nameList;
    };
    inline bool operator==(const GetProvinceListRsp&l, const GetProvinceListRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg && l.nameList == r.nameList;
    }
    inline bool operator!=(const GetProvinceListRsp&l, const GetProvinceListRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetProvinceListRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetProvinceListRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetProvinceListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetProvinceListReq";
        }
        static string MD5()
        {
            return "d78cbc06508bfe992d942181edb06d95";
        }
        ProxyGetProvinceListReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::GetProvinceListReq body;
    };
    inline bool operator==(const ProxyGetProvinceListReq&l, const ProxyGetProvinceListReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetProvinceListReq&l, const ProxyGetProvinceListReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetProvinceListReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetProvinceListReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetProvinceListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetProvinceListRsp";
        }
        static string MD5()
        {
            return "a476def890c368d8f8af40a8e244ff76";
        }
        ProxyGetProvinceListRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::GetProvinceListRsp body;
    };
    inline bool operator==(const ProxyGetProvinceListRsp&l, const ProxyGetProvinceListRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetProvinceListRsp&l, const ProxyGetProvinceListRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetProvinceListRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetProvinceListRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetCityListByProvinceReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetCityListByProvinceReq";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        GetCityListByProvinceReq()
        :provinceName("")
        {
        }
        void resetDefautlt()
        {
            provinceName = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (provinceName != "")
            {
                _os.write(provinceName, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(provinceName, 0, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["provinceName"] = tars::JsonOutput::writeJson(provinceName);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(provinceName,pObj->value["provinceName"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(provinceName,"provinceName");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(provinceName, false);
            return _os;
        }
    public:
        std::string provinceName;
    };
    inline bool operator==(const GetCityListByProvinceReq&l, const GetCityListByProvinceReq&r)
    {
        return l.provinceName == r.provinceName;
    }
    inline bool operator!=(const GetCityListByProvinceReq&l, const GetCityListByProvinceReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetCityListByProvinceReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetCityListByProvinceReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetCityListByProvinceRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetCityListByProvinceRsp";
        }
        static string MD5()
        {
            return "207870fa3e5340da2042f951415ac96b";
        }
        GetCityListByProvinceRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
            _os.write(nameList, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
            _is.read(nameList, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            p->value["nameList"] = tars::JsonOutput::writeJson(nameList);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
            tars::JsonInput::readJson(nameList,pObj->value["nameList"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            _ds.display(nameList,"nameList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(nameList, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
        vector<std::string> nameList;
    };
    inline bool operator==(const GetCityListByProvinceRsp&l, const GetCityListByProvinceRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg && l.nameList == r.nameList;
    }
    inline bool operator!=(const GetCityListByProvinceRsp&l, const GetCityListByProvinceRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetCityListByProvinceRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetCityListByProvinceRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetCityListByProvinceReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetCityListByProvinceReq";
        }
        static string MD5()
        {
            return "e3ac6ee9052d1485613c3daff763320c";
        }
        ProxyGetCityListByProvinceReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::GetCityListByProvinceReq body;
    };
    inline bool operator==(const ProxyGetCityListByProvinceReq&l, const ProxyGetCityListByProvinceReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetCityListByProvinceReq&l, const ProxyGetCityListByProvinceReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetCityListByProvinceReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetCityListByProvinceReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetCityListByProvinceRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetCityListByProvinceRsp";
        }
        static string MD5()
        {
            return "67d4e50e11426dfaa9d11a1134baffc6";
        }
        ProxyGetCityListByProvinceRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::GetCityListByProvinceRsp body;
    };
    inline bool operator==(const ProxyGetCityListByProvinceRsp&l, const ProxyGetCityListByProvinceRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetCityListByProvinceRsp&l, const ProxyGetCityListByProvinceRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetCityListByProvinceRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetCityListByProvinceRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetCountyListByCityReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetCountyListByCityReq";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        GetCountyListByCityReq()
        :cityName("")
        {
        }
        void resetDefautlt()
        {
            cityName = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (cityName != "")
            {
                _os.write(cityName, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(cityName, 0, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["cityName"] = tars::JsonOutput::writeJson(cityName);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(cityName,pObj->value["cityName"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(cityName,"cityName");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(cityName, false);
            return _os;
        }
    public:
        std::string cityName;
    };
    inline bool operator==(const GetCountyListByCityReq&l, const GetCountyListByCityReq&r)
    {
        return l.cityName == r.cityName;
    }
    inline bool operator!=(const GetCountyListByCityReq&l, const GetCountyListByCityReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetCountyListByCityReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetCountyListByCityReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetCountyListByCityRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetCountyListByCityRsp";
        }
        static string MD5()
        {
            return "207870fa3e5340da2042f951415ac96b";
        }
        GetCountyListByCityRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
            _os.write(nameList, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
            _is.read(nameList, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            p->value["nameList"] = tars::JsonOutput::writeJson(nameList);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
            tars::JsonInput::readJson(nameList,pObj->value["nameList"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            _ds.display(nameList,"nameList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(nameList, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
        vector<std::string> nameList;
    };
    inline bool operator==(const GetCountyListByCityRsp&l, const GetCountyListByCityRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg && l.nameList == r.nameList;
    }
    inline bool operator!=(const GetCountyListByCityRsp&l, const GetCountyListByCityRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetCountyListByCityRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetCountyListByCityRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetCountyListByCityReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetCountyListByCityReq";
        }
        static string MD5()
        {
            return "0763eb0a95f78a8102a7b74f4a5b8ace";
        }
        ProxyGetCountyListByCityReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::GetCountyListByCityReq body;
    };
    inline bool operator==(const ProxyGetCountyListByCityReq&l, const ProxyGetCountyListByCityReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetCountyListByCityReq&l, const ProxyGetCountyListByCityReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetCountyListByCityReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetCountyListByCityReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetCountyListByCityRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetCountyListByCityRsp";
        }
        static string MD5()
        {
            return "7d13eb4c8c84609098fc43283bfcee4c";
        }
        ProxyGetCountyListByCityRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::GetCountyListByCityRsp body;
    };
    inline bool operator==(const ProxyGetCountyListByCityRsp&l, const ProxyGetCountyListByCityRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetCountyListByCityRsp&l, const ProxyGetCountyListByCityRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetCountyListByCityRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetCountyListByCityRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ShopCartItem : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ShopCartItem";
        }
        static string MD5()
        {
            return "6e2da97455df8766d2415045ef20828c";
        }
        ShopCartItem()
        :cartId(0),spuId(0),skuId(0),uid(0),price(0),tranPrice(0),num(0),status(0),billNo("")
        {
        }
        void resetDefautlt()
        {
            cartId = 0;
            spuId = 0;
            skuId = 0;
            uid = 0;
            price = 0;
            tranPrice = 0;
            num = 0;
            status = 0;
            billNo = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(cartId, 0);
            _os.write(spuId, 1);
            _os.write(skuId, 2);
            _os.write(uid, 3);
            _os.write(price, 4);
            _os.write(tranPrice, 5);
            _os.write(num, 6);
            _os.write(status, 7);
            _os.write(skuInfo, 8);
            _os.write(billNo, 9);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(cartId, 0, true);
            _is.read(spuId, 1, true);
            _is.read(skuId, 2, true);
            _is.read(uid, 3, true);
            _is.read(price, 4, true);
            _is.read(tranPrice, 5, true);
            _is.read(num, 6, true);
            _is.read(status, 7, true);
            _is.read(skuInfo, 8, true);
            _is.read(billNo, 9, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["cartId"] = tars::JsonOutput::writeJson(cartId);
            p->value["spuId"] = tars::JsonOutput::writeJson(spuId);
            p->value["skuId"] = tars::JsonOutput::writeJson(skuId);
            p->value["uid"] = tars::JsonOutput::writeJson(uid);
            p->value["price"] = tars::JsonOutput::writeJson(price);
            p->value["tranPrice"] = tars::JsonOutput::writeJson(tranPrice);
            p->value["num"] = tars::JsonOutput::writeJson(num);
            p->value["status"] = tars::JsonOutput::writeJson(status);
            p->value["skuInfo"] = tars::JsonOutput::writeJson(skuInfo);
            p->value["billNo"] = tars::JsonOutput::writeJson(billNo);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(cartId,pObj->value["cartId"], true);
            tars::JsonInput::readJson(spuId,pObj->value["spuId"], true);
            tars::JsonInput::readJson(skuId,pObj->value["skuId"], true);
            tars::JsonInput::readJson(uid,pObj->value["uid"], true);
            tars::JsonInput::readJson(price,pObj->value["price"], true);
            tars::JsonInput::readJson(tranPrice,pObj->value["tranPrice"], true);
            tars::JsonInput::readJson(num,pObj->value["num"], true);
            tars::JsonInput::readJson(status,pObj->value["status"], true);
            tars::JsonInput::readJson(skuInfo,pObj->value["skuInfo"], true);
            tars::JsonInput::readJson(billNo,pObj->value["billNo"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(cartId,"cartId");
            _ds.display(spuId,"spuId");
            _ds.display(skuId,"skuId");
            _ds.display(uid,"uid");
            _ds.display(price,"price");
            _ds.display(tranPrice,"tranPrice");
            _ds.display(num,"num");
            _ds.display(status,"status");
            _ds.display(skuInfo,"skuInfo");
            _ds.display(billNo,"billNo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(cartId, true);
            _ds.displaySimple(spuId, true);
            _ds.displaySimple(skuId, true);
            _ds.displaySimple(uid, true);
            _ds.displaySimple(price, true);
            _ds.displaySimple(tranPrice, true);
            _ds.displaySimple(num, true);
            _ds.displaySimple(status, true);
            _ds.displaySimple(skuInfo, true);
            _ds.displaySimple(billNo, false);
            return _os;
        }
    public:
        tars::Int32 cartId;
        tars::Int32 spuId;
        tars::Int32 skuId;
        tars::Int32 uid;
        tars::Int32 price;
        tars::Int32 tranPrice;
        tars::Int32 num;
        tars::Int32 status;
        HardwareApplet::GoodsSKUInfo skuInfo;
        std::string billNo;
    };
    inline bool operator==(const ShopCartItem&l, const ShopCartItem&r)
    {
        return l.cartId == r.cartId && l.spuId == r.spuId && l.skuId == r.skuId && l.uid == r.uid && l.price == r.price && l.tranPrice == r.tranPrice && l.num == r.num && l.status == r.status && l.skuInfo == r.skuInfo && l.billNo == r.billNo;
    }
    inline bool operator!=(const ShopCartItem&l, const ShopCartItem&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ShopCartItem&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ShopCartItem&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct OrderItem : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.OrderItem";
        }
        static string MD5()
        {
            return "20bf26dfce18d9610bbf064dd705b0e9";
        }
        OrderItem()
        :orderId(0),uid(0),payWay(0),status(0),money(0),tranMoney(0),freight(0),billNo("")
        {
        }
        void resetDefautlt()
        {
            orderId = 0;
            uid = 0;
            payWay = 0;
            status = 0;
            money = 0;
            tranMoney = 0;
            freight = 0;
            billNo = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(orderId, 0);
            _os.write(uid, 1);
            _os.write(payWay, 2);
            _os.write(status, 3);
            _os.write(money, 4);
            _os.write(tranMoney, 5);
            _os.write(freight, 6);
            _os.write(billNo, 7);
            _os.write(addressInfo, 8);
            _os.write(itemList, 9);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(orderId, 0, true);
            _is.read(uid, 1, true);
            _is.read(payWay, 2, true);
            _is.read(status, 3, true);
            _is.read(money, 4, true);
            _is.read(tranMoney, 5, true);
            _is.read(freight, 6, true);
            _is.read(billNo, 7, true);
            _is.read(addressInfo, 8, true);
            _is.read(itemList, 9, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["orderId"] = tars::JsonOutput::writeJson(orderId);
            p->value["uid"] = tars::JsonOutput::writeJson(uid);
            p->value["payWay"] = tars::JsonOutput::writeJson(payWay);
            p->value["status"] = tars::JsonOutput::writeJson(status);
            p->value["money"] = tars::JsonOutput::writeJson(money);
            p->value["tranMoney"] = tars::JsonOutput::writeJson(tranMoney);
            p->value["freight"] = tars::JsonOutput::writeJson(freight);
            p->value["billNo"] = tars::JsonOutput::writeJson(billNo);
            p->value["addressInfo"] = tars::JsonOutput::writeJson(addressInfo);
            p->value["itemList"] = tars::JsonOutput::writeJson(itemList);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(orderId,pObj->value["orderId"], true);
            tars::JsonInput::readJson(uid,pObj->value["uid"], true);
            tars::JsonInput::readJson(payWay,pObj->value["payWay"], true);
            tars::JsonInput::readJson(status,pObj->value["status"], true);
            tars::JsonInput::readJson(money,pObj->value["money"], true);
            tars::JsonInput::readJson(tranMoney,pObj->value["tranMoney"], true);
            tars::JsonInput::readJson(freight,pObj->value["freight"], true);
            tars::JsonInput::readJson(billNo,pObj->value["billNo"], true);
            tars::JsonInput::readJson(addressInfo,pObj->value["addressInfo"], true);
            tars::JsonInput::readJson(itemList,pObj->value["itemList"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(orderId,"orderId");
            _ds.display(uid,"uid");
            _ds.display(payWay,"payWay");
            _ds.display(status,"status");
            _ds.display(money,"money");
            _ds.display(tranMoney,"tranMoney");
            _ds.display(freight,"freight");
            _ds.display(billNo,"billNo");
            _ds.display(addressInfo,"addressInfo");
            _ds.display(itemList,"itemList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(orderId, true);
            _ds.displaySimple(uid, true);
            _ds.displaySimple(payWay, true);
            _ds.displaySimple(status, true);
            _ds.displaySimple(money, true);
            _ds.displaySimple(tranMoney, true);
            _ds.displaySimple(freight, true);
            _ds.displaySimple(billNo, true);
            _ds.displaySimple(addressInfo, true);
            _ds.displaySimple(itemList, false);
            return _os;
        }
    public:
        tars::Int32 orderId;
        tars::Int32 uid;
        tars::Int32 payWay;
        tars::Int32 status;
        tars::Int32 money;
        tars::Int32 tranMoney;
        tars::Int32 freight;
        std::string billNo;
        HardwareApplet::AddressInfo addressInfo;
        vector<HardwareApplet::ShopCartItem> itemList;
    };
    inline bool operator==(const OrderItem&l, const OrderItem&r)
    {
        return l.orderId == r.orderId && l.uid == r.uid && l.payWay == r.payWay && l.status == r.status && l.money == r.money && l.tranMoney == r.tranMoney && l.freight == r.freight && l.billNo == r.billNo && l.addressInfo == r.addressInfo && l.itemList == r.itemList;
    }
    inline bool operator!=(const OrderItem&l, const OrderItem&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const OrderItem&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,OrderItem&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AddGoodsToShopCartReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AddGoodsToShopCartReq";
        }
        static string MD5()
        {
            return "b90c756192c1910ca09f59ff5b37d63e";
        }
        AddGoodsToShopCartReq()
        :spuId(0),skuId(0),price(0),tranPrice(0),num(0),status(0)
        {
        }
        void resetDefautlt()
        {
            spuId = 0;
            skuId = 0;
            price = 0;
            tranPrice = 0;
            num = 0;
            status = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(spuId, 0);
            _os.write(skuId, 1);
            _os.write(price, 2);
            _os.write(tranPrice, 3);
            _os.write(num, 4);
            _os.write(status, 5);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(spuId, 0, true);
            _is.read(skuId, 1, true);
            _is.read(price, 2, true);
            _is.read(tranPrice, 3, true);
            _is.read(num, 4, true);
            _is.read(status, 5, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["spuId"] = tars::JsonOutput::writeJson(spuId);
            p->value["skuId"] = tars::JsonOutput::writeJson(skuId);
            p->value["price"] = tars::JsonOutput::writeJson(price);
            p->value["tranPrice"] = tars::JsonOutput::writeJson(tranPrice);
            p->value["num"] = tars::JsonOutput::writeJson(num);
            p->value["status"] = tars::JsonOutput::writeJson(status);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(spuId,pObj->value["spuId"], true);
            tars::JsonInput::readJson(skuId,pObj->value["skuId"], true);
            tars::JsonInput::readJson(price,pObj->value["price"], true);
            tars::JsonInput::readJson(tranPrice,pObj->value["tranPrice"], true);
            tars::JsonInput::readJson(num,pObj->value["num"], true);
            tars::JsonInput::readJson(status,pObj->value["status"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(spuId,"spuId");
            _ds.display(skuId,"skuId");
            _ds.display(price,"price");
            _ds.display(tranPrice,"tranPrice");
            _ds.display(num,"num");
            _ds.display(status,"status");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(spuId, true);
            _ds.displaySimple(skuId, true);
            _ds.displaySimple(price, true);
            _ds.displaySimple(tranPrice, true);
            _ds.displaySimple(num, true);
            _ds.displaySimple(status, false);
            return _os;
        }
    public:
        tars::Int32 spuId;
        tars::Int32 skuId;
        tars::Int32 price;
        tars::Int32 tranPrice;
        tars::Int32 num;
        tars::Int32 status;
    };
    inline bool operator==(const AddGoodsToShopCartReq&l, const AddGoodsToShopCartReq&r)
    {
        return l.spuId == r.spuId && l.skuId == r.skuId && l.price == r.price && l.tranPrice == r.tranPrice && l.num == r.num && l.status == r.status;
    }
    inline bool operator!=(const AddGoodsToShopCartReq&l, const AddGoodsToShopCartReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AddGoodsToShopCartReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AddGoodsToShopCartReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AddGoodsToShopCartRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.AddGoodsToShopCartRsp";
        }
        static string MD5()
        {
            return "b84e4dd5dd1d7c43dbe702512024405f";
        }
        AddGoodsToShopCartRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
    };
    inline bool operator==(const AddGoodsToShopCartRsp&l, const AddGoodsToShopCartRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg;
    }
    inline bool operator!=(const AddGoodsToShopCartRsp&l, const AddGoodsToShopCartRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AddGoodsToShopCartRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AddGoodsToShopCartRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyAddGoodsToShopCartReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyAddGoodsToShopCartReq";
        }
        static string MD5()
        {
            return "71ea2191908ae5896cc482e320d1a45f";
        }
        ProxyAddGoodsToShopCartReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::AddGoodsToShopCartReq body;
    };
    inline bool operator==(const ProxyAddGoodsToShopCartReq&l, const ProxyAddGoodsToShopCartReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyAddGoodsToShopCartReq&l, const ProxyAddGoodsToShopCartReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyAddGoodsToShopCartReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyAddGoodsToShopCartReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyAddGoodsToShopCartRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyAddGoodsToShopCartRsp";
        }
        static string MD5()
        {
            return "2fd76a8c45c0286aeb0c859756a8d4e5";
        }
        ProxyAddGoodsToShopCartRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::AddGoodsToShopCartRsp body;
    };
    inline bool operator==(const ProxyAddGoodsToShopCartRsp&l, const ProxyAddGoodsToShopCartRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyAddGoodsToShopCartRsp&l, const ProxyAddGoodsToShopCartRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyAddGoodsToShopCartRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyAddGoodsToShopCartRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetMyShopCartInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetMyShopCartInfoReq";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        GetMyShopCartInfoReq()
        :reserved_field("")
        {
        }
        void resetDefautlt()
        {
            reserved_field = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(reserved_field, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(reserved_field, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["reserved_field"] = tars::JsonOutput::writeJson(reserved_field);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(reserved_field,pObj->value["reserved_field"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(reserved_field,"reserved_field");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(reserved_field, false);
            return _os;
        }
    public:
        std::string reserved_field;
    };
    inline bool operator==(const GetMyShopCartInfoReq&l, const GetMyShopCartInfoReq&r)
    {
        return l.reserved_field == r.reserved_field;
    }
    inline bool operator!=(const GetMyShopCartInfoReq&l, const GetMyShopCartInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetMyShopCartInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetMyShopCartInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetMyShopCartInfoRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetMyShopCartInfoRsp";
        }
        static string MD5()
        {
            return "5fc70f26ba669330087c816942c55144";
        }
        GetMyShopCartInfoRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
            _os.write(itemList, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
            _is.read(itemList, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            p->value["itemList"] = tars::JsonOutput::writeJson(itemList);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
            tars::JsonInput::readJson(itemList,pObj->value["itemList"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            _ds.display(itemList,"itemList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(itemList, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
        vector<HardwareApplet::ShopCartItem> itemList;
    };
    inline bool operator==(const GetMyShopCartInfoRsp&l, const GetMyShopCartInfoRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg && l.itemList == r.itemList;
    }
    inline bool operator!=(const GetMyShopCartInfoRsp&l, const GetMyShopCartInfoRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetMyShopCartInfoRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetMyShopCartInfoRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetMyShopCartInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetMyShopCartInfoReq";
        }
        static string MD5()
        {
            return "811f886400e0e33ad5e73f31fc1855ff";
        }
        ProxyGetMyShopCartInfoReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::GetMyShopCartInfoReq body;
    };
    inline bool operator==(const ProxyGetMyShopCartInfoReq&l, const ProxyGetMyShopCartInfoReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetMyShopCartInfoReq&l, const ProxyGetMyShopCartInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetMyShopCartInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetMyShopCartInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetMyShopCartInfoRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetMyShopCartInfoRsp";
        }
        static string MD5()
        {
            return "52b5a5517987632b96aa1ee43680a612";
        }
        ProxyGetMyShopCartInfoRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::GetMyShopCartInfoRsp body;
    };
    inline bool operator==(const ProxyGetMyShopCartInfoRsp&l, const ProxyGetMyShopCartInfoRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetMyShopCartInfoRsp&l, const ProxyGetMyShopCartInfoRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetMyShopCartInfoRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetMyShopCartInfoRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct SubmitOrderReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.SubmitOrderReq";
        }
        static string MD5()
        {
            return "d53312d5b3b52ecc7f132413042a0826";
        }
        SubmitOrderReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(item, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(item, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["item"] = tars::JsonOutput::writeJson(item);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(item,pObj->value["item"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(item,"item");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(item, false);
            return _os;
        }
    public:
        HardwareApplet::OrderItem item;
    };
    inline bool operator==(const SubmitOrderReq&l, const SubmitOrderReq&r)
    {
        return l.item == r.item;
    }
    inline bool operator!=(const SubmitOrderReq&l, const SubmitOrderReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const SubmitOrderReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,SubmitOrderReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct SubmitOrderRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.SubmitOrderRsp";
        }
        static string MD5()
        {
            return "b84e4dd5dd1d7c43dbe702512024405f";
        }
        SubmitOrderRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
    };
    inline bool operator==(const SubmitOrderRsp&l, const SubmitOrderRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg;
    }
    inline bool operator!=(const SubmitOrderRsp&l, const SubmitOrderRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const SubmitOrderRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,SubmitOrderRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxySubmitOrderReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxySubmitOrderReq";
        }
        static string MD5()
        {
            return "4037e22eedf97c67b812c08727d2de97";
        }
        ProxySubmitOrderReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::SubmitOrderReq body;
    };
    inline bool operator==(const ProxySubmitOrderReq&l, const ProxySubmitOrderReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxySubmitOrderReq&l, const ProxySubmitOrderReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxySubmitOrderReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxySubmitOrderReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxySubmitOrderRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxySubmitOrderRsp";
        }
        static string MD5()
        {
            return "b0e5ef1b6a4bd49a415a1eb17498e22a";
        }
        ProxySubmitOrderRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::SubmitOrderRsp body;
    };
    inline bool operator==(const ProxySubmitOrderRsp&l, const ProxySubmitOrderRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxySubmitOrderRsp&l, const ProxySubmitOrderRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxySubmitOrderRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxySubmitOrderRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ConfirmOrderReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ConfirmOrderReq";
        }
        static string MD5()
        {
            return "d53312d5b3b52ecc7f132413042a0826";
        }
        ConfirmOrderReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(item, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(item, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["item"] = tars::JsonOutput::writeJson(item);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(item,pObj->value["item"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(item,"item");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(item, false);
            return _os;
        }
    public:
        HardwareApplet::OrderItem item;
    };
    inline bool operator==(const ConfirmOrderReq&l, const ConfirmOrderReq&r)
    {
        return l.item == r.item;
    }
    inline bool operator!=(const ConfirmOrderReq&l, const ConfirmOrderReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ConfirmOrderReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ConfirmOrderReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ConfirmOrderRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ConfirmOrderRsp";
        }
        static string MD5()
        {
            return "b84e4dd5dd1d7c43dbe702512024405f";
        }
        ConfirmOrderRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
    };
    inline bool operator==(const ConfirmOrderRsp&l, const ConfirmOrderRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg;
    }
    inline bool operator!=(const ConfirmOrderRsp&l, const ConfirmOrderRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ConfirmOrderRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ConfirmOrderRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyConfirmOrderReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyConfirmOrderReq";
        }
        static string MD5()
        {
            return "cb81919b7fe8db0105b54e2db2b9ec29";
        }
        ProxyConfirmOrderReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::ConfirmOrderReq body;
    };
    inline bool operator==(const ProxyConfirmOrderReq&l, const ProxyConfirmOrderReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyConfirmOrderReq&l, const ProxyConfirmOrderReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyConfirmOrderReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyConfirmOrderReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyConfirmOrderRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyConfirmOrderRsp";
        }
        static string MD5()
        {
            return "0265bea234c3a5ad618ddfd047b195f8";
        }
        ProxyConfirmOrderRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::ConfirmOrderRsp body;
    };
    inline bool operator==(const ProxyConfirmOrderRsp&l, const ProxyConfirmOrderRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyConfirmOrderRsp&l, const ProxyConfirmOrderRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyConfirmOrderRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyConfirmOrderRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ConfirmGoodsTranPriceReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ConfirmGoodsTranPriceReq";
        }
        static string MD5()
        {
            return "9d21082e205765385f5a8957cb35a0fd";
        }
        ConfirmGoodsTranPriceReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(item, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(item, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["item"] = tars::JsonOutput::writeJson(item);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(item,pObj->value["item"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(item,"item");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(item, false);
            return _os;
        }
    public:
        HardwareApplet::ShopCartItem item;
    };
    inline bool operator==(const ConfirmGoodsTranPriceReq&l, const ConfirmGoodsTranPriceReq&r)
    {
        return l.item == r.item;
    }
    inline bool operator!=(const ConfirmGoodsTranPriceReq&l, const ConfirmGoodsTranPriceReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ConfirmGoodsTranPriceReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ConfirmGoodsTranPriceReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ConfirmGoodsTranPriceRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ConfirmGoodsTranPriceRsp";
        }
        static string MD5()
        {
            return "b84e4dd5dd1d7c43dbe702512024405f";
        }
        ConfirmGoodsTranPriceRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
    };
    inline bool operator==(const ConfirmGoodsTranPriceRsp&l, const ConfirmGoodsTranPriceRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg;
    }
    inline bool operator!=(const ConfirmGoodsTranPriceRsp&l, const ConfirmGoodsTranPriceRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ConfirmGoodsTranPriceRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ConfirmGoodsTranPriceRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyConfirmGoodsTranPriceReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyConfirmGoodsTranPriceReq";
        }
        static string MD5()
        {
            return "37d5a52660d7bf96c13ebd1a31bbcb3a";
        }
        ProxyConfirmGoodsTranPriceReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::ConfirmGoodsTranPriceReq body;
    };
    inline bool operator==(const ProxyConfirmGoodsTranPriceReq&l, const ProxyConfirmGoodsTranPriceReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyConfirmGoodsTranPriceReq&l, const ProxyConfirmGoodsTranPriceReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyConfirmGoodsTranPriceReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyConfirmGoodsTranPriceReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyConfirmGoodsTranPriceRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyConfirmGoodsTranPriceRsp";
        }
        static string MD5()
        {
            return "8af101f7df204a158020a22b0e355fe3";
        }
        ProxyConfirmGoodsTranPriceRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::ConfirmGoodsTranPriceRsp body;
    };
    inline bool operator==(const ProxyConfirmGoodsTranPriceRsp&l, const ProxyConfirmGoodsTranPriceRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyConfirmGoodsTranPriceRsp&l, const ProxyConfirmGoodsTranPriceRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyConfirmGoodsTranPriceRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyConfirmGoodsTranPriceRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct DeliverGoodsReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.DeliverGoodsReq";
        }
        static string MD5()
        {
            return "75f1be2757c92eb6699b52ef20b9f989";
        }
        DeliverGoodsReq()
        :billno(""),status(0)
        {
        }
        void resetDefautlt()
        {
            billno = "";
            status = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(billno, 0);
            _os.write(status, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(billno, 0, true);
            _is.read(status, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["billno"] = tars::JsonOutput::writeJson(billno);
            p->value["status"] = tars::JsonOutput::writeJson(status);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(billno,pObj->value["billno"], true);
            tars::JsonInput::readJson(status,pObj->value["status"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(billno,"billno");
            _ds.display(status,"status");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(billno, true);
            _ds.displaySimple(status, false);
            return _os;
        }
    public:
        std::string billno;
        tars::Int32 status;
    };
    inline bool operator==(const DeliverGoodsReq&l, const DeliverGoodsReq&r)
    {
        return l.billno == r.billno && l.status == r.status;
    }
    inline bool operator!=(const DeliverGoodsReq&l, const DeliverGoodsReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const DeliverGoodsReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,DeliverGoodsReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct DeliverGoodsRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.DeliverGoodsRsp";
        }
        static string MD5()
        {
            return "b84e4dd5dd1d7c43dbe702512024405f";
        }
        DeliverGoodsRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
    };
    inline bool operator==(const DeliverGoodsRsp&l, const DeliverGoodsRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg;
    }
    inline bool operator!=(const DeliverGoodsRsp&l, const DeliverGoodsRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const DeliverGoodsRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,DeliverGoodsRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyDeliverGoodsReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyDeliverGoodsReq";
        }
        static string MD5()
        {
            return "a88a72183b94088f6d8adf7d5b7d97c2";
        }
        ProxyDeliverGoodsReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::DeliverGoodsReq body;
    };
    inline bool operator==(const ProxyDeliverGoodsReq&l, const ProxyDeliverGoodsReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyDeliverGoodsReq&l, const ProxyDeliverGoodsReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyDeliverGoodsReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyDeliverGoodsReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyDeliverGoodsRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyDeliverGoodsRsp";
        }
        static string MD5()
        {
            return "c083a90407a58351f937a1fbfcbfbb79";
        }
        ProxyDeliverGoodsRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::DeliverGoodsRsp body;
    };
    inline bool operator==(const ProxyDeliverGoodsRsp&l, const ProxyDeliverGoodsRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyDeliverGoodsRsp&l, const ProxyDeliverGoodsRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyDeliverGoodsRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyDeliverGoodsRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetMyOrderListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetMyOrderListReq";
        }
        static string MD5()
        {
            return "7b010a6336d210a506b1eb4bf4c1e014";
        }
        GetMyOrderListReq()
        :status(0)
        {
        }
        void resetDefautlt()
        {
            status = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(status, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(status, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["status"] = tars::JsonOutput::writeJson(status);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(status,pObj->value["status"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(status,"status");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(status, false);
            return _os;
        }
    public:
        tars::Int32 status;
    };
    inline bool operator==(const GetMyOrderListReq&l, const GetMyOrderListReq&r)
    {
        return l.status == r.status;
    }
    inline bool operator!=(const GetMyOrderListReq&l, const GetMyOrderListReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetMyOrderListReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetMyOrderListReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetMyOrderListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetMyOrderListRsp";
        }
        static string MD5()
        {
            return "eb7f4f61f1416c1a830b0d89fa658c6d";
        }
        GetMyOrderListRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
            _os.write(itemList, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
            _is.read(itemList, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            p->value["itemList"] = tars::JsonOutput::writeJson(itemList);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
            tars::JsonInput::readJson(itemList,pObj->value["itemList"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            _ds.display(itemList,"itemList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(itemList, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
        vector<HardwareApplet::OrderItem> itemList;
    };
    inline bool operator==(const GetMyOrderListRsp&l, const GetMyOrderListRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg && l.itemList == r.itemList;
    }
    inline bool operator!=(const GetMyOrderListRsp&l, const GetMyOrderListRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetMyOrderListRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetMyOrderListRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetMyOrderListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetMyOrderListReq";
        }
        static string MD5()
        {
            return "57860f1a69c8eb83b2d31a0013aa58ed";
        }
        ProxyGetMyOrderListReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::GetMyOrderListReq body;
    };
    inline bool operator==(const ProxyGetMyOrderListReq&l, const ProxyGetMyOrderListReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetMyOrderListReq&l, const ProxyGetMyOrderListReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetMyOrderListReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetMyOrderListReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetMyOrderListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetMyOrderListRsp";
        }
        static string MD5()
        {
            return "a32522d97ecd3cfefc63328a21aac891";
        }
        ProxyGetMyOrderListRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::GetMyOrderListRsp body;
    };
    inline bool operator==(const ProxyGetMyOrderListRsp&l, const ProxyGetMyOrderListRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetMyOrderListRsp&l, const ProxyGetMyOrderListRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetMyOrderListRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetMyOrderListRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetOrderListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetOrderListReq";
        }
        static string MD5()
        {
            return "aea402d67a51a1314b2b40d2714a382f";
        }
        GetOrderListReq()
        :status(0),pageNo(0),pageSize(0)
        {
        }
        void resetDefautlt()
        {
            status = 0;
            pageNo = 0;
            pageSize = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(status, 0);
            _os.write(pageNo, 1);
            _os.write(pageSize, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(status, 0, true);
            _is.read(pageNo, 1, true);
            _is.read(pageSize, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["status"] = tars::JsonOutput::writeJson(status);
            p->value["pageNo"] = tars::JsonOutput::writeJson(pageNo);
            p->value["pageSize"] = tars::JsonOutput::writeJson(pageSize);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(status,pObj->value["status"], true);
            tars::JsonInput::readJson(pageNo,pObj->value["pageNo"], true);
            tars::JsonInput::readJson(pageSize,pObj->value["pageSize"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(status,"status");
            _ds.display(pageNo,"pageNo");
            _ds.display(pageSize,"pageSize");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(status, true);
            _ds.displaySimple(pageNo, true);
            _ds.displaySimple(pageSize, false);
            return _os;
        }
    public:
        tars::Int32 status;
        tars::Int32 pageNo;
        tars::Int32 pageSize;
    };
    inline bool operator==(const GetOrderListReq&l, const GetOrderListReq&r)
    {
        return l.status == r.status && l.pageNo == r.pageNo && l.pageSize == r.pageSize;
    }
    inline bool operator!=(const GetOrderListReq&l, const GetOrderListReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetOrderListReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetOrderListReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetOrderListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetOrderListRsp";
        }
        static string MD5()
        {
            return "290780d3ce76a8f2d78ffaf048c30f0d";
        }
        GetOrderListRsp()
        :ret(0),errmsg(""),hasNext(0)
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
            hasNext = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
            _os.write(itemList, 2);
            _os.write(hasNext, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
            _is.read(itemList, 2, true);
            _is.read(hasNext, 3, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            p->value["itemList"] = tars::JsonOutput::writeJson(itemList);
            p->value["hasNext"] = tars::JsonOutput::writeJson(hasNext);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
            tars::JsonInput::readJson(itemList,pObj->value["itemList"], true);
            tars::JsonInput::readJson(hasNext,pObj->value["hasNext"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            _ds.display(itemList,"itemList");
            _ds.display(hasNext,"hasNext");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(itemList, true);
            _ds.displaySimple(hasNext, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
        vector<HardwareApplet::OrderItem> itemList;
        tars::Int32 hasNext;
    };
    inline bool operator==(const GetOrderListRsp&l, const GetOrderListRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg && l.itemList == r.itemList && l.hasNext == r.hasNext;
    }
    inline bool operator!=(const GetOrderListRsp&l, const GetOrderListRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetOrderListRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetOrderListRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetOrderListReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetOrderListReq";
        }
        static string MD5()
        {
            return "7c5356c5fbe12153d372b5e0d5de89ed";
        }
        ProxyGetOrderListReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::GetOrderListReq body;
    };
    inline bool operator==(const ProxyGetOrderListReq&l, const ProxyGetOrderListReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetOrderListReq&l, const ProxyGetOrderListReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetOrderListReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetOrderListReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetOrderListRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetOrderListRsp";
        }
        static string MD5()
        {
            return "6d160e3cb759799510246281352144be";
        }
        ProxyGetOrderListRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::GetOrderListRsp body;
    };
    inline bool operator==(const ProxyGetOrderListRsp&l, const ProxyGetOrderListRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetOrderListRsp&l, const ProxyGetOrderListRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetOrderListRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetOrderListRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetOrderDetailReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetOrderDetailReq";
        }
        static string MD5()
        {
            return "7b010a6336d210a506b1eb4bf4c1e014";
        }
        GetOrderDetailReq()
        :orderId(0)
        {
        }
        void resetDefautlt()
        {
            orderId = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(orderId, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(orderId, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["orderId"] = tars::JsonOutput::writeJson(orderId);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(orderId,pObj->value["orderId"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(orderId,"orderId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(orderId, false);
            return _os;
        }
    public:
        tars::Int32 orderId;
    };
    inline bool operator==(const GetOrderDetailReq&l, const GetOrderDetailReq&r)
    {
        return l.orderId == r.orderId;
    }
    inline bool operator!=(const GetOrderDetailReq&l, const GetOrderDetailReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetOrderDetailReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetOrderDetailReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GetOrderDetailRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.GetOrderDetailRsp";
        }
        static string MD5()
        {
            return "04a3762b991f1599c19367e627860275";
        }
        GetOrderDetailRsp()
        :ret(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            ret = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ret, 0);
            _os.write(errmsg, 1);
            _os.write(item, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ret, 0, true);
            _is.read(errmsg, 1, true);
            _is.read(item, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
            p->value["item"] = tars::JsonOutput::writeJson(item);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(errmsg,pObj->value["errmsg"], true);
            tars::JsonInput::readJson(item,pObj->value["item"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ret,"ret");
            _ds.display(errmsg,"errmsg");
            _ds.display(item,"item");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(item, false);
            return _os;
        }
    public:
        tars::Int32 ret;
        std::string errmsg;
        HardwareApplet::OrderItem item;
    };
    inline bool operator==(const GetOrderDetailRsp&l, const GetOrderDetailRsp&r)
    {
        return l.ret == r.ret && l.errmsg == r.errmsg && l.item == r.item;
    }
    inline bool operator!=(const GetOrderDetailRsp&l, const GetOrderDetailRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GetOrderDetailRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GetOrderDetailRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetOrderDetailReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetOrderDetailReq";
        }
        static string MD5()
        {
            return "67adafdda808479bd96bd47a1146f455";
        }
        ProxyGetOrderDetailReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyReqHead head;
        HardwareApplet::GetOrderDetailReq body;
    };
    inline bool operator==(const ProxyGetOrderDetailReq&l, const ProxyGetOrderDetailReq&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetOrderDetailReq&l, const ProxyGetOrderDetailReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetOrderDetailReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetOrderDetailReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ProxyGetOrderDetailRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "HardwareApplet.ProxyGetOrderDetailRsp";
        }
        static string MD5()
        {
            return "27ce9a5ae08f76e753d0ca2384272ae5";
        }
        ProxyGetOrderDetailRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(head, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(head, 0, true);
            _is.read(body, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["head"] = tars::JsonOutput::writeJson(head);
            p->value["body"] = tars::JsonOutput::writeJson(body);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(head,pObj->value["head"], true);
            tars::JsonInput::readJson(body,pObj->value["body"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        HardwareApplet::ProxyRspHead head;
        HardwareApplet::GetOrderDetailRsp body;
    };
    inline bool operator==(const ProxyGetOrderDetailRsp&l, const ProxyGetOrderDetailRsp&r)
    {
        return l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const ProxyGetOrderDetailRsp&l, const ProxyGetOrderDetailRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ProxyGetOrderDetailRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ProxyGetOrderDetailRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }


}



#endif
