# 1、 协议设计理论
随着移动互联网的发展，微服务架构成了后台服务架构的标配。通常支撑微服务架构的底层技术是RPC，RPC在通信的时候，数据的序列化、反序列化，跨平台等等是需要解决的问题。通常情况下，跨平台是通过IDL来解决的，通信过程中的协议设计也非常重要，通常有如下目标：  
 - 解析效率：互联网服务具有海量服务的特点，高校的解析效率可以节约大量的CPU。
 - 编码长度：编码的效率决定了使用的网络带宽。
 - 易于实现和学习：协议应该简单好用，不需要大而全的东西。  
 - 后向兼容性:互联网业务的特点就是灵活多变，易于升级，可以很好的兼容老的协议。我觉得随着机器性能的提升，这个因素更加成为一个核心目标。  
 - 易于阅读和理解

协议设计主要就是尽量达到这些目标。  

协议设计需要解决两个最为基本的核心问题是：  
 - 序列化、反序列化
 - 判断数据包的完整性。
解决了这两个最基本的问题之后，机器之间就可以完成通信。  
满足了最基本问题之后，后向兼容性方面也是需要考虑的问题：如何支持升级、可用性如何维护。  

接下来就先学习互联网后台协议解决前两个基本问题的方法，然后再看看tars是怎么做的，后向兼容性又是如何做的。  

## 1.1 序列化/反序列化
序列化我们常称之为编码，或者打包，反序列化常称之为解码，或者解包。常用的序列化/反序列化方式主要有以下几种：  
1. TLV（tag-length-value）编码：Protobuf/thrift/tars/ASN BER都属于这种。TLV编码基本原理是每个字段打一个二进制包，每个包包含tag、length、value 3个部分  
 - * ：tag: 一般占用1个字节，表示数据类型，有的编码方式（Protobuf/thrift/tars）中tag还包含字段的id，有的编码方式（ASN BER）不包含字段的id。在包含字段id的序列化方式中，id是字段的标志，协议可以灵活的增删字段，只要保证字段id唯一，就能兼容解析，非常适合互联网业务的开发，因此大部分互联网RPC协议都是带有id的编码方式。   
 - * length：一个整数，表示后面数据块的长度，Protobuf/thrift/tars的序列化有些不包含length字段，因为大部分数据类型的长度都可以根据tag中的类型信息得到。  
 - * value：真正的数据内容。  

 - TLV的编码方式有如下特点：  
 - * 解析效率高：不需要转义字符。  
 - * 编码长度低：元数据占用空间少(例如json格式中，元数据占用的空间打，key的名字有时候占用的长度比其值占用的都大)。  
 - * 不易实现：虽然实现起来比较复杂，但是业界有很多良好的实现，通常是和IDL绑定，自动生成代码，进行序列化、反序列化，开发效率反而往往很高。  
 - * 兼容性高：通过tag中包含id信息的方式，双方可以独立升级。
 - * 不易阅读和理解：因为是二进制协议，肉眼难以识别。  

2. 文本流编码：例如xml/json都属于这种。基本原理是把每个字段打一个字符串形式的包，通过键值对（key-value）的方式存储数据，key是字段的名字（对比上面TLV编码采用id的方式标志一个字段），特殊字符特别是非文本字符需要做适当转义（例如通过base64编码），转义为xml/json的合法字符。xml的解析效率低于json，而编码长度高于json，json作为序列化的方式一般是优于xml的。  

 - 文本流编码的特点是：
 - * 解析效率低
 - * 编码长度高
 - * 易于实现
 - * 可扩展性高
 - * 可读性好
可见，对性能要求较高的场景而言，这种序列化/反序列化方式不合适。  

3. 固定结构编码：基本原理是，协议约定了传输字段类型和字段含义，和TLV的方式类似，但是没有了tag和len，只有value  
 - 固定结构编码如果协议升级了又需要保证兼容性，那么可以在协议中增加一个“版本号”字段，然后根据版本号决定如何序列化和反序列化，这样可以保证协议的兼容性。但是这样会导致代码非常混乱。
 
 - 固定结构编码的特点是：
 - * 解析效率搞  
 - * 编码长度更低：对于TLV而言  
 - * 易于实现：都是已经约定好固定的格式。  
 - * 可读性方面略微优于TLV方式。
 - * 灵活性和兼容性非常差。  

因此，互联网协议中，通常使用TLV方式实现序列化/反序列化。   

## 1.2 判断数据包的完整性

现在序列化/反序列化完成了，我们可以把结构化数据转化成字节流，并从字节流中恢复结构化数据。但是我们知道，TCP协议是安全的字节流协议，但是并不负责完整的数据包的处理，在TCP的角度，它不管你的数据包，只是当作字节流处理，因此，判断数据包的完整性就得应用层实现了（内核层只负责将字节传输过去），通常来说，这个由框架完成。业务开发只关心业务逻辑。  

实现判断数据包的完整性通常有两种方式：  
1.  在序列化后的buffer前面增加一个采用固定结构编码的头部，头部长度和结构固定，其中有个字段存储包总长度。收包时，先接收固定字节数的头部，解出这个包完整长度，按此长度接收包体。  
2. 在序列化后的buffer前面增加一个字符流的头部，其中有个字段存储包总长度，根据特殊字符（比如根据\n 或者\0）判断头部的完整性。这样通常比1中的方式要麻烦一些，http、memcached和radis采用的是这种方式，不过好处就是头部是可扩展的，头部的长度是可变的，这样的话，我们就能在头部携带一些附加信息。收包的时候，先判断已收到的数据中是否包含结束符，收到结束符后解析包头，解出这个包完整长度，按此长度接收包体。  


至此，我们就为两台机器的通信做了基础的工作，得到了协议设计最核心部分的基本思想和框架。涉及到具体业务的时候，基于这些思想加以适当调整，就能都得到一个合适的协议。  






