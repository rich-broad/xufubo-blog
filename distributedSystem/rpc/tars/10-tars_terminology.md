# 概述
任何一个软件都有它对应的术语，tars也不例外，在对tars进行深入研究之前，我们先对tars的术语进行介绍。如果你有其他的RPC中间件的经验下列的术语对你来说将是熟悉的。  

## 1 客户端和服务器
术语客户端和服务器是应用程序特定部分的不固定的名称，它们的真实含义要依据具体的场景来定：
 - 客户端是主动的实体。他们向服务器发出请求。
 - 服务器是被动的实体。他们接受客户端请求，并做出响应。  
随着移动互联网的发展，后端服务需要面对海量的用户，这时，传统的单服务模式无法满足业务需求了，由此演化出了基于RPC的微服务分布式系统。因此，通常来说，服务器并不是“纯粹”的服务器（因为在这种场景下，它们从不发出请求，只对请求作出响应）。相反，服务器通常一方面作为一些客户端的服务器，另一方面，为了满足他们的客户端的请求而作为一个客户端向另一个服务器发出请求；这种场景下，它既包含客户端的成分，也包含服务器的成分。同样地，客户端通常并不是“纯粹”的客户端，（因为在这个意义上，它们只从服务器请求服务）。相反，客户端通常也是客户端--服务器的结合体。例如：客户端可能请求一个服务器上的长时间操作作为开始操作的一部分，客户端可以提供一个回调对象用于服务器操作完成时通知客户端。在这种情况下，当客户端被回调是又可以理解为服务器。tars框架就是基于RPC的微服务开发框架，对于tars服务，也会通常包含这两种成分。    

## 2 tars对象
tars对象是一个抽象的概念性实体，通常用于表示一个服务实体或者一个服务实体的一部分（因为后边我们会看到，一个tars服务可以包含多个对象），tars对象具有以下几点特征：  
 - Tars对象是在本地或远程地址空间的一个可以响应客户端请求的实体。  
 - 一个Tars对象可以在单个服务器上存在一个实例，也可以在多台服务器上存在多个实例。如果一个对象同时有多个实例（存在于多台服务器上），它仍是**一个**Tars对象。Tars框架是基于名字服务的，你可以认为一个对象在Tars的体系中具有一个名字，也就是一个完成整个分布式系统中某个功能模块的一个服务。  
 - 每个Tars对象都有一个或多个接口（即：函数）。客户端可以发出调用操作的请求。
 - 接口具有零个或多个参数，以及**一个**返回值。参数和返回值有一个特定的类型和名称，并有一个方向：输入（in）参数由客户端初始化并传递给服务器; 输出（out）参数由服务器初始化并传递给客户端。（接口返回值只是一种特殊的out参数）。  
 - 每个Tars对象都有一个唯一的对象标识。Tars对象模型假定对象标识是全局唯一的，也就是说，在一个Tars通信领域内没有两个对象可以有相同的标识。在实践中，不需要使对象的身份是全球唯一的，只要保证对象标识不与你感兴趣的域中的其他任何标识发生冲突即可。例如：假设在企业A中部署了Tars框架，企业B也使用了这套框架，然而它们都部署在各自的内网中。他们之间没有任何关系，只要他们内部不重复即可，二者之间互不影响，那么在二者之间就可以有相同的对象标识，不会冲突。  

## 3 代理
为了客户端能够调用Tars对象上的接口，客户端必须持有Tars对象的代理。代理是本地客户端地址空间的一个实体； 它代表了远程Tars对象。当客户端调用某个对象的代理上的接口时，Tars框架的客户端运行时系统产生如下操作：  
 - 1. 定位Tars对象，即：通过tars的名字服务来获取tars对象的IP：port列表；
 - 2. 如果对象没有一个实例在运行，则调用失败；
 - 3. 如果对象正在运行，则选择一个实例来准备调用；
 - 4. 向Tars对象通过网络传输参数（期间会进行序列化、组包和网络传递）；
 - 5. 等待对象调用完成；
 - 6. 返回输出参数和返回值到客户端（或在错误的情况下抛出异常）；

代理封装了此序列中所有步骤的必要信息。特别地，代理包括:  
 - 定位，以便客户端联系正确的对象服务器
 - 标识在服务器上的对象
 - 指定对象上的接口（函数）。
代理的人类可读标识是一个字符串，例如：
```
MobileAssist.LogDistributeServer.LogDistributeObj。  
```
代理分为两种，直接代理和间接代理。  

### 3.1 直接代理
直接代理包含了对象标识和对象所在的服务器的地址信息。对象的地址信息完全被指定：
例如：  
```
MobileAssist.LogDistributeServer.LogDistributeObj@ tcp -h 10.51.151.220 -p 10015 -t 60000: tcp -h 10.212.12.216 -t 60000 -p 10003
```

### 3.2 间接代理
间接代理仅仅包含了对象标识。如：MobileAssist.LogDistributeServer.LogDistributeObj。  

 > **注意：**一个间接代理不包含寻址信息。为了确定对象正确的服务器地址，客户端运行时系统会传递对象代理信息到一个定位服务器，定位服务器利用对象标识查找到对象所在的服务器地址，返回给客户端。此时客户端运行时系统知道了Tars对象的服务器地址，可以发起调用了。当然了，这就要保证定位服务器的稳定。疑问来了：为什么在调用之前要这么做呢，使用直接代理不是更好吗？这是因为：通常一个对象拥有多个在多台机器上的实例，而且这些实例中可能某一时刻某个机器挂了，那么这个对象实例就不能用了，如果使用直接代理，那么客户端实际上并不知道，这就有问题了。如果直接代理是写死在代码里的，就要改动并重新编译，如果改成配置，就要手动维护。总之很麻烦。同时，对于互联网系统来说，扩容是常有的事，当对象又在某个机器上增加了一个实例时，也需要如上添加。因此利用间接代理，即可解决以上两个问题。不管对象实例是扩容还是缩容，对于建立在其上的应用程序来说，都是透明的，对开发人员都是福音。整个定位的过程类似于DNS系统。这使得基于tars框架构建的分布式系统更加灵活。  

## 4 绑定
将代理中的信息解析为协议地址的过程称为绑定。绑定分为直接绑定和间接绑定，毫不奇怪，直接绑定用于直接代理，间接绑定用于间接代理。  
间接绑定的主要优点是它允许我们移动对象实例所在的服务器（即更改其地址），而不会使客户端持有的现有代理无效。换句话说，直接代理避免了额外的查找来定位服务器，但是如果服务器被移动到不同的机器，则使用直接代理的服务器将不再工作。另一方面，即使我们移动服务器，间接代理将继续工作。

## 5 对象实例复制（扩容）
复制是高可用的基石，同时扩容也能增加系统的容量，因此扩容是互联网系统非常重要的特点。tars框架支持对象实例的复制（扩容）。  
Tars对象实例复制其实就是扩容。即将Tars对象实例在一台新服务器上部署并让其运行起来的行为。这就保证了如果一台机器发生故障，另一台机器依然可以提供服务。通过复制，客户端可以选择代理中的一个对象实例来提供服务，当这个对象出了问题还可以选择别的对象提供服务，而不是直接失败。**这里还涉及到扩容的tars对象实例如何被发现等问题？**Tars的具体做法后边我们进行详细剖析。  
前述的间接代理和间接绑定的实现原理也保证了扩容的透明执行，而不会干扰应用开发人员或者运维人员。但是任何一个服务都有配置，扩容带来了方便，也引出了问题。如何保证各个实例之间的配置一致呢，其实解决的办法很简单，可以搞一个配置中心服务。以对象标识为key来维护其配置文件。为了支持set分组，可以以对象标识和set分组名为key来维护配置文件。后续进行实现的具体剖析。  

## 6 Servant
如前所述：Tars对象是有类型，身份标识和地址信息的概念实体。然而，客户端请求最终必须被具体的可以被调用的服务器端实体处理。客户端的请求最终必须在服务器内部的可执行代码得到处理。在Tars框架中，服务端提供一个Servant来处理客户端的请求（即：业务逻辑的处理）。这个Servant其实是服务开发者编写的类实例。  

## 7 同步调用
默认情况下，Tars使用的请求分派模型是同步的远程过程调用：操作调用的行为就像是本地过程调用，也就是说，客户端线程被挂起直到服务端响应回来，或者出现超时等异常。

## 8 异步调用
Tars还支持异步方法调用（AMI） ：客户端也可以发起异步调用，即：客户端像往常一样使用代理，但除了传递通常的参数以外，还要传递一个回调对象；客户端调用立即返回。一旦操作完成，客户端运行时传递操作的结果给回调对象（或在失败时传递异常信息），并调用回调对象中执行相应的方法。

## 9 单向调用
客户端可以发起单向调用操作。单向调用具有“尽力”语义。对于单向调用，客户端运行时系统会把调用交给本地传输，并且客户端只要将请求放到本地传输缓冲区中就算调用完成了。实际的调用，由操作系统异步发送。服务器不会响应单向调用，即：流量只能从客户机到服务器。单向调用是不可靠的。例如，目标对象可能不存在，在这种情况下，调用被简单地丢弃。操作可以被分派给服务器中的Servant，但操作可能失败（例如，因为参数值无效）; 即便是这样，客户端也不会收到任何通知。单向调用没有返回值，没有输出参数，并且不抛出用户异常。对于服务器侧的应用程序**业务逻辑**代码而言，单向调用是透明的，也就是说，应用程序逻辑代码没有办法区分单向调用和双向调用。

## 10 方法分派
即服务端被客户端调用时，运行时系统需要解包，然后解析出客户端调用的接口之后，调用服务端对应的Servant实现代码。对于服务端的异步回调，在客户端也需要做这样的处理。  

## 11 运行时异常
任何调用操作都可能产生一个运行时异常。如连接失败，连接超时，或资源分配失败等。

## 12 属性
Tars框架的运行时系统的大部分组件都被实现为可配的。例如：客户端异步处理线程、服务端Servant线程数量等等。

## 13 Node
一台物理机或者一台虚拟机被tars抽象为一个node来管理，一台node上可以部署多个不同的tars对象实例（业务服务）。tars框架中，会通过在Node上运行的框架基础服务NodeServer来对Node上的tars对象实例进行管理。  

如上我们了解了tars框架的基本术语，后边我们的学习会通过他们来描述tars框架的实现。  


